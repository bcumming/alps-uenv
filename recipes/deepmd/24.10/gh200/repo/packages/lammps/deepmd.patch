From 9f0c4b7923070d5e5a26ab9f2da95cba1e68af42 Mon Sep 17 00:00:00 2001
From: Mathieu Taillefumier <mathieu.taillefumier@free.fr>
Date: Thu, 11 Jul 2024 15:29:59 +0200
Subject: [PATCH] Add deepmd support

---
 cmake/CMakeLists.txt                        |   32 +
 src/USER-DEEPMD/Install.sh                  |   68 +
 src/USER-DEEPMD/compute_deeptensor_atom.cpp |  183 +++
 src/USER-DEEPMD/compute_deeptensor_atom.h   |   53 +
 src/USER-DEEPMD/deepmd_version.h            |   17 +
 src/USER-DEEPMD/env.sh                      |   11 +
 src/USER-DEEPMD/fix_dplr.cpp                |  799 ++++++++++
 src/USER-DEEPMD/fix_dplr.h                  |   87 ++
 src/USER-DEEPMD/fix_ttm_dp.h                |   18 +
 src/USER-DEEPMD/lmp_version.sh              |    9 +
 src/USER-DEEPMD/pair_deepmd.cpp             | 1540 +++++++++++++++++++
 src/USER-DEEPMD/pair_deepmd.h               |  145 ++
 src/USER-DEEPMD/pppm_dplr.cpp               |  430 ++++++
 src/USER-DEEPMD/pppm_dplr.h                 |   44 +
 14 files changed, 3436 insertions(+)
 create mode 100644 src/USER-DEEPMD/Install.sh
 create mode 100644 src/USER-DEEPMD/compute_deeptensor_atom.cpp
 create mode 100644 src/USER-DEEPMD/compute_deeptensor_atom.h
 create mode 100644 src/USER-DEEPMD/deepmd_version.h
 create mode 100644 src/USER-DEEPMD/env.sh
 create mode 100644 src/USER-DEEPMD/fix_dplr.cpp
 create mode 100644 src/USER-DEEPMD/fix_dplr.h
 create mode 100644 src/USER-DEEPMD/fix_ttm_dp.h
 create mode 100755 src/USER-DEEPMD/lmp_version.sh
 create mode 100644 src/USER-DEEPMD/pair_deepmd.cpp
 create mode 100644 src/USER-DEEPMD/pair_deepmd.h
 create mode 100644 src/USER-DEEPMD/pppm_dplr.cpp
 create mode 100644 src/USER-DEEPMD/pppm_dplr.h

diff --git a/cmake/CMakeLists.txt b/cmake/CMakeLists.txt
index bbae4cb35d..a0bf858e53 100644
--- a/cmake/CMakeLists.txt
+++ b/cmake/CMakeLists.txt
@@ -1079,3 +1079,35 @@ if(ENABLE_TESTING)
     message(STATUS "Collecting code coverage data")
   endif()
 endif()
+# This file should be included in the end of
+# ${LAMMPS_SOURCE_DIR}/cmake/CMakeLists.txt
+# include(/path/to/deepmd_source/source/lmp/builtin.cmake)
+
+# assume LAMMPS CMake file has been executed, so these target/variables exist:
+# lammps LAMMPS_SOURCE_DIR get_lammps_version
+
+get_lammps_version(${LAMMPS_SOURCE_DIR}/version.h LAMMPS_VERSION_NUMBER)
+
+file(GLOB DEEPMD_LMP_SRC ${LAMMPS_SOURCE_DIR}/USER-DEEPMD/*.cpp)
+
+find_package(DeePMD REQUIRED)
+target_sources(
+  lammps
+  PRIVATE ${DEEPMD_LMP_SRC}
+          ${LAMMPS_SOURCE_DIR}/KSPACE/pppm.cpp # for pppm_dplr
+          ${LAMMPS_SOURCE_DIR}/KSPACE/fft3d.cpp
+          ${LAMMPS_SOURCE_DIR}/KSPACE/fft3d_wrap.cpp
+          ${LAMMPS_SOURCE_DIR}/KSPACE/remap.cpp
+          ${LAMMPS_SOURCE_DIR}/KSPACE/remap_wrap.cpp
+          ${LAMMPS_SOURCE_DIR}/EXTRA-FIX/fix_ttm.cpp # for ttm
+)
+target_link_libraries(lammps PUBLIC DeePMD::deepmd_c)
+target_include_directories(
+  lammps PRIVATE ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_LIST_DIR}
+                 ${LAMMPS_SOURCE_DIR}/KSPACE ${LAMMPS_SOURCE_DIR}/EXTRA-FIX)
+target_compile_definitions(
+  lammps PRIVATE "LAMMPS_VERSION_NUMBER=${LAMMPS_VERSION_NUMBER}")
+
+# register styles
+registerstyles(${CMAKE_CURRENT_LIST_DIR})
+generatestyleheaders(${LAMMPS_STYLE_HEADERS_DIR})
diff --git a/src/USER-DEEPMD/Install.sh b/src/USER-DEEPMD/Install.sh
new file mode 100644
index 0000000000..3120a923ab
--- /dev/null
+++ b/src/USER-DEEPMD/Install.sh
@@ -0,0 +1,68 @@
+#!/bin/bash
+
+source ./env.sh
+
+# Install/unInstall package files in LAMMPS
+# mode = 0/1/2 for uninstall/install/update
+
+mode=$1
+
+# enforce using portable C locale
+LC_ALL=C
+export LC_ALL
+
+# arg1 = file, arg2 = file it depends on
+
+action() {
+	if (test $mode = 0); then
+		rm -f ../$1
+	elif (! cmp -s $1 ../$1); then
+		if (test -z "$2" || test -e ../$2); then
+			cp $1 ..
+			if (test $mode = 2); then
+				echo "  updating src/$1"
+			fi
+		fi
+	elif (test -n "$2"); then
+		if (test ! -e ../$2); then
+			rm -f ../$1
+		fi
+	fi
+}
+
+if (test $1 = 1); then
+	if (test ! -e ../pppm.cpp); then
+		echo "Must install KSPACE package with USER-DEEPMD package"
+		exit 1
+	fi
+	if (test ! -e ../fix_ttm.cpp); then
+		echo "Must install EXTRA-FIX package with USER-DEEPMD package"
+		exit 1
+	fi
+fi
+
+# all package files with no dependencies
+
+for file in *.cpp *.h; do
+	test -f ${file} && action $file
+done
+
+# edit 2 Makefile.package files to include/exclude package info
+
+if (test $1 = 1); then
+
+	if (test -e ../Makefile.package); then
+		sed -i -e "s|^PKG_INC =[ \t].*|& $NNP_INC|" ../Makefile.package
+		sed -i -e "s|^PKG_PATH =[ \t].*|& $NNP_PATH|" ../Makefile.package
+		sed -i -e "s|^PKG_LIB =[ \t].*|& $NNP_LIB|" ../Makefile.package
+	fi
+
+elif (test $mode = 0); then
+
+	if (test -e ../Makefile.package); then
+		sed -i -e "s|$NNP_INC||g" ../Makefile.package
+		sed -i -e "s|$NNP_PATH||g" ../Makefile.package
+		sed -i -e "s|$NNP_LIB||g" ../Makefile.package
+	fi
+
+fi
diff --git a/src/USER-DEEPMD/compute_deeptensor_atom.cpp b/src/USER-DEEPMD/compute_deeptensor_atom.cpp
new file mode 100644
index 0000000000..6e6e9508b7
--- /dev/null
+++ b/src/USER-DEEPMD/compute_deeptensor_atom.cpp
@@ -0,0 +1,183 @@
+// SPDX-License-Identifier: LGPL-3.0-or-later
+#include "compute_deeptensor_atom.h"
+
+#include <algorithm>
+#include <cstring>
+
+#include "atom.h"
+#include "comm.h"
+#include "domain.h"
+#include "error.h"
+#include "fix.h"
+#include "force.h"
+#include "memory.h"
+#include "modify.h"
+#include "neigh_list.h"
+#include "neigh_request.h"
+#include "neighbor.h"
+#include "pair.h"
+#include "update.h"
+
+using namespace LAMMPS_NS;
+
+#define VALUETYPE double
+
+/* ---------------------------------------------------------------------- */
+
+ComputeDeeptensorAtom::ComputeDeeptensorAtom(LAMMPS *lmp, int narg, char **arg)
+    : Compute(lmp, narg, arg), dp(lmp), tensor(nullptr) {
+  if (strcmp(update->unit_style, "lj") == 0) {
+    error->all(FLERR,
+               "Compute deeptensor/atom does not support unit style lj. Please "
+               "use other "
+               "unit styles like metal or real unit instead. You may set it by "
+               "\"units metal\" or \"units real\"");
+  }
+
+  if (narg < 4) {
+    error->all(FLERR, "Illegal compute deeptensor/atom command");
+  }
+
+  // parse args
+  std::string model_file = std::string(arg[3]);
+
+  // initialize deeptensor
+  int gpu_rank = dp.get_node_rank();
+  try {
+    dt.init(model_file, gpu_rank);
+  } catch (deepmd_compat::deepmd_exception &e) {
+    error->one(FLERR, e.what());
+  }
+  sel_types = dt.sel_types();
+  std::sort(sel_types.begin(), sel_types.end());
+
+  peratom_flag = 1;
+  size_peratom_cols = dt.output_dim();
+  pressatomflag = 0;
+  timeflag = 1;
+
+  nmax = 0;
+
+  dist_unit_cvt_factor = force->angstrom;
+}
+
+/* ---------------------------------------------------------------------- */
+
+ComputeDeeptensorAtom::~ComputeDeeptensorAtom() { memory->destroy(tensor); }
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeDeeptensorAtom::init() {
+  // need an occasional full neighbor list
+
+#if LAMMPS_VERSION_NUMBER >= 20220324
+  neighbor->add_request(this,
+                        NeighConst::REQ_FULL | NeighConst::REQ_OCCASIONAL);
+#else
+  int irequest = neighbor->request(this, instance_me);
+  neighbor->requests[irequest]->half = 0;
+  neighbor->requests[irequest]->pair = 0;
+  neighbor->requests[irequest]->compute = 1;
+  neighbor->requests[irequest]->full = 1;
+  neighbor->requests[irequest]->occasional = 1;
+#endif
+}
+
+void ComputeDeeptensorAtom::init_list(int /*id*/, NeighList *ptr) {
+  list = ptr;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeDeeptensorAtom::compute_peratom() {
+  invoked_peratom = update->ntimestep;
+
+  // grow local tensor array if necessary
+  // needs to be atom->nmax in length
+  if (atom->nmax > nmax) {
+    memory->destroy(tensor);
+    nmax = atom->nmax;
+    memory->create(tensor, nmax, size_peratom_cols, "deeptensor/atom:tensor");
+    array_atom = tensor;
+  }
+
+  double **x = atom->x;
+  double **f = atom->f;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  int nghost = atom->nghost;
+  int nall = nlocal + nghost;
+  int newton_pair = force->newton_pair;
+
+  std::vector<VALUETYPE> dcoord(nall * 3, 0.);
+  std::vector<VALUETYPE> dbox(9, 0);
+  std::vector<int> dtype(nall);
+  // get type
+  for (int ii = 0; ii < nall; ++ii) {
+    dtype[ii] = type[ii] - 1;
+  }
+  // get box
+  dbox[0] = domain->h[0] / dist_unit_cvt_factor;  // xx
+  dbox[4] = domain->h[1] / dist_unit_cvt_factor;  // yy
+  dbox[8] = domain->h[2] / dist_unit_cvt_factor;  // zz
+  dbox[7] = domain->h[3] / dist_unit_cvt_factor;  // zy
+  dbox[6] = domain->h[4] / dist_unit_cvt_factor;  // zx
+  dbox[3] = domain->h[5] / dist_unit_cvt_factor;  // yx
+  // get coord
+  for (int ii = 0; ii < nall; ++ii) {
+    for (int dd = 0; dd < 3; ++dd) {
+      dcoord[ii * 3 + dd] =
+          (x[ii][dd] - domain->boxlo[dd]) / dist_unit_cvt_factor;
+    }
+  }
+
+  // invoke full neighbor list (will copy or build if necessary)
+  neighbor->build_one(list);
+  deepmd_compat::InputNlist lmp_list(list->inum, list->ilist, list->numneigh,
+                                     list->firstneigh);
+
+  // declare outputs
+  std::vector<VALUETYPE> gtensor, force, virial, atensor, avirial;
+
+  // compute tensors
+  try {
+    dt.compute(gtensor, force, virial, atensor, avirial, dcoord, dtype, dbox,
+               nghost, lmp_list);
+  } catch (deepmd_compat::deepmd_exception &e) {
+    error->one(FLERR, e.what());
+  }
+
+  // store the result in tensor
+  int iter_tensor = 0;
+  for (int ii = 0; ii < nlocal; ++ii) {
+    std::vector<int>::iterator _it =
+        std::find(sel_types.begin(), sel_types.end(), dtype[ii]);
+    bool selected = (_it != sel_types.end());
+    bool ingroup = (mask[ii] & groupbit);
+    // record when selected and in group
+    if (selected && ingroup) {
+      for (int jj = 0; jj < size_peratom_cols; ++jj) {
+        tensor[ii][jj] = atensor[iter_tensor + jj] * dist_unit_cvt_factor;
+      }
+    }
+    // if not selected or not in group set to 0.
+    else {
+      for (int jj = 0; jj < size_peratom_cols; ++jj) {
+        tensor[ii][jj] = 0.0;
+      }
+    }
+    if (selected) {
+      iter_tensor += size_peratom_cols;
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based array
+------------------------------------------------------------------------- */
+
+double ComputeDeeptensorAtom::memory_usage() {
+  double bytes = static_cast<size_t>(nmax) * size_peratom_cols * sizeof(double);
+  return bytes;
+}
diff --git a/src/USER-DEEPMD/compute_deeptensor_atom.h b/src/USER-DEEPMD/compute_deeptensor_atom.h
new file mode 100644
index 0000000000..a90283aa9e
--- /dev/null
+++ b/src/USER-DEEPMD/compute_deeptensor_atom.h
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: LGPL-3.0-or-later
+#ifdef COMPUTE_CLASS
+// clang-format off
+ComputeStyle(deeptensor/atom, ComputeDeeptensorAtom)
+// clang-format on
+#else
+
+#ifndef LMP_COMPUTE_DEEPTENSOR_ATOM_H
+#define LMP_COMPUTE_DEEPTENSOR_ATOM_H
+
+#include "compute.h"
+#include "pair_deepmd.h"
+#ifdef DP_USE_CXX_API
+#ifdef LMPPLUGIN
+#include "DeepTensor.h"
+#else
+#include "deepmd/DeepTensor.h"
+#endif
+namespace deepmd_compat = deepmd;
+#else
+#ifdef LMPPLUGIN
+#include "deepmd.hpp"
+#else
+#include "deepmd/deepmd.hpp"
+#endif
+namespace deepmd_compat = deepmd::hpp;
+#endif
+
+namespace LAMMPS_NS {
+
+class ComputeDeeptensorAtom : public Compute {
+ public:
+  ComputeDeeptensorAtom(class LAMMPS *, int, char **);
+  ~ComputeDeeptensorAtom() override;
+  void init() override;
+  void compute_peratom() override;
+  double memory_usage() override;
+  void init_list(int, class NeighList *) override;
+  double dist_unit_cvt_factor;
+
+ private:
+  int nmax;
+  double **tensor;
+  PairDeepMD dp;
+  class NeighList *list;
+  deepmd_compat::DeepTensor dt;
+  std::vector<int> sel_types;
+};
+
+}  // namespace LAMMPS_NS
+
+#endif
+#endif
diff --git a/src/USER-DEEPMD/deepmd_version.h b/src/USER-DEEPMD/deepmd_version.h
new file mode 100644
index 0000000000..580bf9b25e
--- /dev/null
+++ b/src/USER-DEEPMD/deepmd_version.h
@@ -0,0 +1,17 @@
+#define GIT_SUMM v2.2.11-1-g6dafa507
+#define GIT_HASH 6dafa507
+#define GIT_BRANCH r2
+#define GIT_DATE 2024-07-06 23:29:41 +0800
+#define DEEPMD_ROOT /usr/local
+#define TensorFlow_INCLUDE_DIRS /users/tmathieu/spack/opt/spack/linux-sles15-neoverse_v2/gcc-12.3.0/py-tensorflow-2.16.2-ndeftb4qrlcbilvfj7qwtfgypil5pzfn/lib/python3.11/site-packages/tensorflow/include;/users/tmathieu/spack/opt/spack/linux-sles15-neoverse_v2/gcc-12.3.0/py-tensorflow-2.16.2-ndeftb4qrlcbilvfj7qwtfgypil5pzfn/lib/python3.11/site-packages/tensorflow/include
+#define TensorFlow_LIBRARY /users/tmathieu/spack/opt/spack/linux-sles15-neoverse_v2/gcc-12.3.0/py-tensorflow-2.16.2-ndeftb4qrlcbilvfj7qwtfgypil5pzfn/lib/python3.11/site-packages/tensorflow/libtensorflow_cc.so.2
+#define DPMD_CVT_STR(...) #__VA_ARGS__
+#define DPMD_CVT_ASSTR(X) DPMD_CVT_STR(X)
+#define STR_GIT_SUMM DPMD_CVT_ASSTR(GIT_SUMM)
+#define STR_GIT_HASH DPMD_CVT_ASSTR(GIT_HASH)
+#define STR_GIT_BRANCH DPMD_CVT_ASSTR(GIT_BRANCH)
+#define STR_GIT_DATE DPMD_CVT_ASSTR(GIT_DATE)
+#define STR_FLOAT_PREC DPMD_CVT_ASSTR(FLOAT_PREC)
+#define STR_DEEPMD_ROOT DPMD_CVT_ASSTR(DEEPMD_ROOT)
+#define STR_TensorFlow_INCLUDE_DIRS DPMD_CVT_ASSTR(TensorFlow_INCLUDE_DIRS)
+#define STR_TensorFlow_LIBRARY DPMD_CVT_ASSTR(TensorFlow_LIBRARY)
diff --git a/src/USER-DEEPMD/env.sh b/src/USER-DEEPMD/env.sh
new file mode 100644
index 0000000000..7612e4e358
--- /dev/null
+++ b/src/USER-DEEPMD/env.sh
@@ -0,0 +1,11 @@
+DEEPMD_ROOT=/usr/local
+TENSORFLOW_INCLUDE_DIRS=""
+TENSORFLOW_LIBRARY_PATH="/users/tmathieu/spack/opt/spack/linux-sles15-neoverse_v2/gcc-12.3.0/py-tensorflow-2.16.2-ndeftb4qrlcbilvfj7qwtfgypil5pzfn/lib/python3.11/site-packages/tensorflow"
+
+TF_INCLUDE_DIRS=`echo $TENSORFLOW_INCLUDE_DIRS | sed "s/;/ -I/g"`
+TF_LIBRARY_PATH=`echo $TENSORFLOW_LIBRARY_PATH | sed "s/;/ -L/g"`
+TF_RPATH=`echo $TENSORFLOW_LIBRARY_PATH | sed "s/;/ -Wl,-rpath=/g"`
+
+NNP_INC=" -DLAMMPS_VERSION_NUMBER=$(./lmp_version.sh) -I$DEEPMD_ROOT/include/ "
+NNP_PATH=" -L$TF_LIBRARY_PATH -L$DEEPMD_ROOT/lib"
+NNP_LIB=" -Wl,--no-as-needed -ldeepmd_c -Wl,-rpath=$TF_RPATH -Wl,-rpath=$DEEPMD_ROOT/lib"
diff --git a/src/USER-DEEPMD/fix_dplr.cpp b/src/USER-DEEPMD/fix_dplr.cpp
new file mode 100644
index 0000000000..57bbd5765a
--- /dev/null
+++ b/src/USER-DEEPMD/fix_dplr.cpp
@@ -0,0 +1,799 @@
+// SPDX-License-Identifier: LGPL-3.0-or-later
+#include "fix_dplr.h"
+
+#include <iomanip>
+#include <iostream>
+#include <limits>
+#include <sstream>
+
+#include "atom.h"
+#include "comm.h"
+#include "domain.h"
+#include "error.h"
+#include "fix.h"
+#include "force.h"
+#include "input.h"
+#include "modify.h"
+#include "neigh_list.h"
+#include "neighbor.h"
+#include "pppm_dplr.h"
+#include "update.h"
+#include "variable.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+using namespace std;
+
+static bool is_key(const string &input) {
+  vector<string> keys;
+  keys.push_back("model");
+  keys.push_back("type_associate");
+  keys.push_back("bond_type");
+  keys.push_back("efield");
+  for (int ii = 0; ii < keys.size(); ++ii) {
+    if (input == keys[ii]) {
+      return true;
+    }
+  }
+  return false;
+}
+
+FixDPLR::FixDPLR(LAMMPS *lmp, int narg, char **arg)
+    : Fix(lmp, narg, arg),
+      xstr(nullptr),
+      ystr(nullptr),
+      zstr(nullptr),
+      efield(3, 0.0),
+      efield_fsum(4, 0.0),
+      efield_fsum_all(4, 0.0),
+      efield_force_flag(0) {
+#if LAMMPS_VERSION_NUMBER >= 20210210
+  // lammps/lammps#2560
+  energy_global_flag = 1;
+  virial_global_flag = 1;
+#else
+  virial_flag = 1;
+#endif
+
+  scalar_flag = 1;
+  vector_flag = 1;
+  size_vector = 3;
+  qe2f = force->qe2f;
+  xstyle = ystyle = zstyle = NONE;
+
+  if (strcmp(update->unit_style, "lj") == 0) {
+    error->all(FLERR,
+               "Fix dplr does not support unit style lj. Please use other "
+               "unit styles like metal or real unit instead. You may set it by "
+               "\"units metal\" or \"units real\"");
+  }
+
+  int iarg = 3;
+  vector<int> map_vec;
+  bond_type.clear();
+  while (iarg < narg) {
+    if (!is_key(arg[iarg])) {
+      error->all(FLERR, "Illegal fix command\nwrong number of parameters\n");
+    }
+    if (string(arg[iarg]) == string("model")) {
+      if (iarg + 1 > narg) {
+        error->all(FLERR, "Illegal fix adapt command");
+      }
+      model = string(arg[iarg + 1]);
+      iarg += 2;
+    } else if (string(arg[iarg]) == string("efield")) {
+      if (iarg + 3 > narg) {
+        error->all(FLERR,
+                   "Illegal fix adapt command, efield should be provided 3 "
+                   "float numbers");
+      }
+      if (utils::strmatch(arg[iarg + 1], "^v_")) {
+        xstr = utils::strdup(arg[iarg + 1] + 2);
+      } else {
+        efield[0] = qe2f * utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+        xstyle = CONSTANT;
+      }
+
+      if (utils::strmatch(arg[iarg + 2], "^v_")) {
+        ystr = utils::strdup(arg[iarg + 2] + 2);
+      } else {
+        efield[1] = qe2f * utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+        ystyle = CONSTANT;
+      }
+
+      if (utils::strmatch(arg[iarg + 3], "^v_")) {
+        zstr = utils::strdup(arg[iarg + 3] + 2);
+      } else {
+        efield[2] = qe2f * utils::numeric(FLERR, arg[iarg + 3], false, lmp);
+        zstyle = CONSTANT;
+      }
+      iarg += 4;
+    } else if (string(arg[iarg]) == string("type_associate")) {
+      int iend = iarg + 1;
+      while (iend < narg && (!is_key(arg[iend]))) {
+        map_vec.push_back(atoi(arg[iend]) - 1);
+        iend++;
+      }
+      iarg = iend;
+    } else if (string(arg[iarg]) == string("bond_type")) {
+      int iend = iarg + 1;
+      while (iend < narg && (!is_key(arg[iend]))) {
+        bond_type.push_back(atoi(arg[iend]) - 1);
+        iend++;
+      }
+      sort(bond_type.begin(), bond_type.end());
+      iarg = iend;
+    } else {
+      break;
+    }
+  }
+  assert(map_vec.size() % 2 == 0 &&
+         "number of ints provided by type_associate should be even");
+
+  // dpt.init(model);
+  // dtm.init("frozen_model.pb");
+  try {
+    dpt.init(model, 0, "dipole_charge");
+    dtm.init(model, 0, "dipole_charge");
+  } catch (deepmd_compat::deepmd_exception &e) {
+    error->one(FLERR, e.what());
+  }
+
+  pair_deepmd = (PairDeepMD *)force->pair_match("deepmd", 1);
+  if (!pair_deepmd) {
+    error->all(FLERR, "pair_style deepmd should be set before this fix\n");
+  }
+  ener_unit_cvt_factor = pair_deepmd->ener_unit_cvt_factor;
+  dist_unit_cvt_factor = pair_deepmd->dist_unit_cvt_factor;
+  force_unit_cvt_factor = pair_deepmd->force_unit_cvt_factor;
+
+  int n = atom->ntypes;
+  std::vector<std::string> type_names = pair_deepmd->type_names;
+  std::vector<std::string> type_map;
+  std::string type_map_str;
+  dpt.get_type_map(type_map_str);
+  // convert the string to a vector of strings
+  std::istringstream iss(type_map_str);
+  std::string type_name;
+  while (iss >> type_name) {
+    type_map.push_back(type_name);
+  }
+  if (type_names.size() == 0 || type_map.size() == 0) {
+    type_idx_map.resize(n);
+    for (int ii = 0; ii < n; ++ii) {
+      type_idx_map[ii] = ii;
+    }
+  } else {
+    type_idx_map.clear();
+    for (std::string type_name : type_names) {
+      bool found_element = false;
+      for (int ii = 0; ii < type_map.size(); ++ii) {
+        if (type_map[ii] == type_name) {
+          type_idx_map.push_back(ii);
+          found_element = true;
+          break;
+        }
+      }
+      if (!found_element && "NULL" == type_name) {
+        type_idx_map.push_back(type_map.size());  // ghost type
+        found_element = true;
+      }
+      if (!found_element) {
+        error->all(FLERR, "pair_coeff: element " + type_name +
+                              " not found in the DPLR model");
+      }
+    }
+    int numb_types = type_idx_map.size();
+    if (numb_types < n) {
+      type_idx_map.resize(n);
+      for (int ii = numb_types; ii < n; ++ii) {
+        type_idx_map[ii] = ii;
+      }
+    }
+  }
+
+  for (int ii = 0; ii < map_vec.size() / 2; ++ii) {
+    type_asso[type_idx_map[map_vec[ii * 2 + 0]]] =
+        type_idx_map[map_vec[ii * 2 + 1]];
+    bk_type_asso[type_idx_map[map_vec[ii * 2 + 1]]] =
+        type_idx_map[map_vec[ii * 2 + 0]];
+  }
+
+  sel_type = dpt.sel_types();
+  sort(sel_type.begin(), sel_type.end());
+  dpl_type.clear();
+  for (int ii = 0; ii < sel_type.size(); ++ii) {
+    dpl_type.push_back(type_asso[sel_type[ii]]);
+  }
+
+  // set comm size needed by this fix
+  comm_reverse = 3;
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixDPLR::~FixDPLR() {
+  delete[] xstr;
+  delete[] ystr;
+  delete[] zstr;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixDPLR::setmask() {
+  int mask = 0;
+#if LAMMPS_VERSION_NUMBER < 20210210
+  // THERMO_ENERGY removed in lammps/lammps#2560
+  mask |= THERMO_ENERGY;
+#endif
+  mask |= POST_INTEGRATE;
+  mask |= PRE_FORCE;
+  mask |= POST_FORCE;
+  mask |= MIN_PRE_EXCHANGE;
+  mask |= MIN_PRE_FORCE;
+  mask |= MIN_POST_FORCE;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::init() {
+  // double **xx = atom->x;
+  // double **vv = atom->v;
+  // int nlocal = atom->nlocal;
+  // for (int ii = 0; ii < nlocal; ++ii){
+  //   cout << xx[ii][0] << " "
+  // 	 << xx[ii][1] << " "
+  // 	 << xx[ii][2] << "   "
+  // 	 << vv[ii][0] << " "
+  // 	 << vv[ii][1] << " "
+  // 	 << vv[ii][2] << " "
+  // 	 << endl;
+  // }
+  // check variables
+
+  if (xstr) {
+    xvar = input->variable->find(xstr);
+    if (xvar < 0) {
+      error->all(FLERR, "Variable {} for x-field in fix {} does not exist",
+                 xstr, style);
+    }
+    if (input->variable->equalstyle(xvar)) {
+      xstyle = EQUAL;
+    } else {
+      error->all(FLERR, "Variable {} for x-field in fix {} is invalid style",
+                 xstr, style);
+    }
+  }
+
+  if (ystr) {
+    yvar = input->variable->find(ystr);
+    if (yvar < 0) {
+      error->all(FLERR, "Variable {} for y-field in fix {} does not exist",
+                 ystr, style);
+    }
+    if (input->variable->equalstyle(yvar)) {
+      ystyle = EQUAL;
+    } else {
+      error->all(FLERR, "Variable {} for y-field in fix {} is invalid style",
+                 ystr, style);
+    }
+  }
+
+  if (zstr) {
+    zvar = input->variable->find(zstr);
+    if (zvar < 0) {
+      error->all(FLERR, "Variable {} for z-field in fix {} does not exist",
+                 zstr, style);
+    }
+    if (input->variable->equalstyle(zvar)) {
+      zstyle = EQUAL;
+    } else {
+      error->all(FLERR, "Variable {} for z-field in fix {} is invalid style",
+                 zstr, style);
+    }
+  }
+
+  if (xstyle == EQUAL || ystyle == EQUAL || zstyle == EQUAL) {
+    varflag = EQUAL;
+  } else {
+    varflag = CONSTANT;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::setup_pre_force(int vflag) { pre_force(vflag); }
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::setup(int vflag) {
+  // if (strstr(update->integrate_style,"verlet"))
+  post_force(vflag);
+  // else {
+  //   error->all(FLERR, "respa is not supported by this fix");
+  // }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::min_setup(int vflag) { setup(vflag); }
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::get_valid_pairs(vector<pair<int, int> > &pairs) {
+  pairs.clear();
+
+  int nlocal = atom->nlocal;
+  int nghost = atom->nghost;
+  int nall = nlocal + nghost;
+  vector<int> dtype(nall);
+  // get type
+  int *type = atom->type;
+  for (int ii = 0; ii < nall; ++ii) {
+    dtype[ii] = type_idx_map[type[ii] - 1];
+  }
+
+  int **bondlist = neighbor->bondlist;
+  int nbondlist = neighbor->nbondlist;
+  for (int ii = 0; ii < nbondlist; ++ii) {
+    int idx0 = -1, idx1 = -1;
+    int bd_type = bondlist[ii][2] - 1;
+    if (!binary_search(bond_type.begin(), bond_type.end(), bd_type)) {
+      continue;
+    }
+    std::vector<int>::iterator it =
+        find(sel_type.begin(), sel_type.end(), dtype[bondlist[ii][0]]);
+    if (it != sel_type.end()) {
+      int idx_type = distance(sel_type.begin(), it);
+      if (dtype[bondlist[ii][1]] == dpl_type[idx_type]) {
+        idx0 = bondlist[ii][0];
+        idx1 = bondlist[ii][1];
+      } else {
+        char str[300];
+        sprintf(str,
+                "Invalid pair: %d %d \n       A virtual atom of type %d is "
+                "expected, but the type of atom %d is "
+                "%d.\n       Please check your data file carefully.\n",
+                atom->tag[bondlist[ii][0]], atom->tag[bondlist[ii][1]],
+                dpl_type[idx_type] + 1, atom->tag[bondlist[ii][1]],
+                type[bondlist[ii][1]]);
+        error->all(FLERR, str);
+      }
+    } else {
+      it = find(sel_type.begin(), sel_type.end(), dtype[bondlist[ii][1]]);
+      if (it != sel_type.end()) {
+        int idx_type = distance(sel_type.begin(), it);
+        if (dtype[bondlist[ii][0]] == dpl_type[idx_type]) {
+          idx0 = bondlist[ii][1];
+          idx1 = bondlist[ii][0];
+        } else {
+          char str[300];
+          sprintf(str,
+                  "Invalid pair: %d %d \n       A virtual atom of type %d is "
+                  "expected, but the type of atom %d is %d.\n       Please "
+                  "check your data file carefully.\n",
+                  atom->tag[bondlist[ii][0]], atom->tag[bondlist[ii][1]],
+                  dpl_type[idx_type] + 1, atom->tag[bondlist[ii][0]],
+                  type[bondlist[ii][0]]);
+          error->all(FLERR, str);
+        }
+      } else {
+        char str[300];
+        sprintf(str,
+                "Invalid pair: %d %d \n       They are not expected to have "
+                "Wannier centroid.\n       Please check your data file "
+                "carefully.\n",
+                atom->tag[bondlist[ii][0]], atom->tag[bondlist[ii][1]]);
+        error->all(FLERR, str);
+      }
+    }
+    if (!(idx0 < nlocal && idx1 < nlocal)) {
+      error->all(FLERR,
+                 "find a bonded pair that is not on the same processor, "
+                 "something should not happen");
+    }
+    pairs.push_back(pair<int, int>(idx0, idx1));
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::post_integrate() {
+  double **x = atom->x;
+  double **v = atom->v;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  int nghost = atom->nghost;
+  int nall = nlocal + nghost;
+
+  vector<pair<int, int> > valid_pairs;
+  get_valid_pairs(valid_pairs);
+
+  for (int ii = 0; ii < valid_pairs.size(); ++ii) {
+    int idx0 = valid_pairs[ii].first;
+    int idx1 = valid_pairs[ii].second;
+    for (int dd = 0; dd < 3; ++dd) {
+      x[idx1][dd] = x[idx0][dd];
+      v[idx1][dd] = v[idx0][dd];
+      // v[idx1][dd] = 0.0;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::pre_force(int vflag) {
+  double **x = atom->x;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  int nghost = atom->nghost;
+  int nall = nlocal + nghost;
+
+  // if (eflag_atom) {
+  //   error->all(FLERR,"atomic energy calculation is not supported by this
+  //   fix\n");
+  // }
+
+  // declear inputs
+  vector<int> dtype(nall);
+  vector<FLOAT_PREC> dbox(9, 0);
+  vector<FLOAT_PREC> dcoord(nall * 3, 0.);
+  // get type
+  for (int ii = 0; ii < nall; ++ii) {
+    dtype[ii] = type_idx_map[type[ii] - 1];
+  }
+  // get box
+  dbox[0] = domain->h[0] / dist_unit_cvt_factor;  // xx
+  dbox[4] = domain->h[1] / dist_unit_cvt_factor;  // yy
+  dbox[8] = domain->h[2] / dist_unit_cvt_factor;  // zz
+  dbox[7] = domain->h[3] / dist_unit_cvt_factor;  // zy
+  dbox[6] = domain->h[4] / dist_unit_cvt_factor;  // zx
+  dbox[3] = domain->h[5] / dist_unit_cvt_factor;  // yx
+  // get coord
+  for (int ii = 0; ii < nall; ++ii) {
+    for (int dd = 0; dd < 3; ++dd) {
+      dcoord[ii * 3 + dd] =
+          (x[ii][dd] - domain->boxlo[dd]) / dist_unit_cvt_factor;
+    }
+  }
+  // get lammps nlist
+  NeighList *list = pair_deepmd->list;
+  deepmd_compat::InputNlist lmp_list(list->inum, list->ilist, list->numneigh,
+                                     list->firstneigh);
+  // declear output
+  vector<FLOAT_PREC> tensor;
+  // compute
+  try {
+    dpt.compute(tensor, dcoord, dtype, dbox, nghost, lmp_list);
+  } catch (deepmd_compat::deepmd_exception &e) {
+    error->one(FLERR, e.what());
+  }
+  // cout << "tensor of size " << tensor.size() << endl;
+  // cout << "nghost " << nghost << endl;
+  // cout << "nall " << dtype.size() << endl;
+  // cout << "nloc " << nlocal << endl;
+  // for (int ii = 0; ii < tensor.size(); ++ii){
+  //   if (ii%3 == 0){
+  //     cout << endl;
+  //   }
+  //   cout << tensor[ii] << "\t";
+  // }
+  // cout << endl;
+  // for (int ii = 0; ii < nlocal * 3; ++ii){
+  //   if (ii%3 == 0){
+  //     cout << endl;
+  //   }
+  //   cout << dcoord[ii] << "\t";
+  // }
+  // int max_type = 0;
+  // for (int ii = 0; ii < dtype.size(); ++ii){
+  //   if (dtype[ii] > max_type) {
+  //     max_type = dtype[ii];
+  //   }
+  // }
+
+  vector<int> sel_fwd, sel_bwd;
+  int sel_nghost;
+  deepmd_compat::select_by_type(sel_fwd, sel_bwd, sel_nghost, dcoord, dtype,
+                                nghost, sel_type);
+  int sel_nall = sel_bwd.size();
+  int sel_nloc = sel_nall - sel_nghost;
+  vector<int> sel_type(sel_bwd.size());
+  deepmd_compat::select_map<int>(sel_type, dtype, sel_fwd, 1);
+
+  // Yixiao: because the deeptensor already return the correct order, the
+  // following map is no longer needed deepmd_compat::AtomMap<FLOAT_PREC>
+  // atom_map(sel_type.begin(), sel_type.begin() + sel_nloc); const
+  // vector<int> & sort_fwd_map(atom_map.get_fwd_map());
+
+  vector<pair<int, int> > valid_pairs;
+  get_valid_pairs(valid_pairs);
+
+  int odim = dpt.output_dim();
+  assert(odim == 3);
+  dipole_recd.resize(static_cast<size_t>(nall) * 3);
+  fill(dipole_recd.begin(), dipole_recd.end(), 0.0);
+  for (int ii = 0; ii < valid_pairs.size(); ++ii) {
+    int idx0 = valid_pairs[ii].first;
+    int idx1 = valid_pairs[ii].second;
+    assert(idx0 < sel_fwd.size());  // && sel_fwd[idx0] < sort_fwd_map.size());
+    // Yixiao: the sort map is no longer needed
+    // int res_idx = sort_fwd_map[sel_fwd[idx0]];
+    int res_idx = sel_fwd[idx0];
+    // int ret_idx = dpl_bwd[res_idx];
+    atom->image[idx1] = atom->image[idx0];
+    for (int dd = 0; dd < 3; ++dd) {
+      x[idx1][dd] =
+          x[idx0][dd] + tensor[res_idx * 3 + dd] * dist_unit_cvt_factor;
+      // res_buff[idx1 * odim + dd] = tensor[res_idx * odim + dd];
+      dipole_recd[idx0 * 3 + dd] =
+          tensor[res_idx * 3 + dd] * dist_unit_cvt_factor;
+    }
+  }
+  // cout << "-------------------- fix/dplr: pre force " << endl;
+  // for (int ii = 0; ii < nlocal; ++ii){
+  //   cout << ii << "    ";
+  //   for (int dd = 0; dd < 3; ++dd){
+  //     cout << x[ii][dd] << " " ;
+  //   }
+  //   cout << endl;
+  // }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::post_force(int vflag) {
+  if (vflag) {
+    v_setup(vflag);
+  } else {
+    evflag = 0;
+  }
+  if (vflag_atom) {
+    error->all(FLERR,
+               "atomic virial calculation is not supported by this fix\n");
+  }
+
+  if (!(varflag == CONSTANT)) {
+    update_efield_variables();
+  }
+
+  PPPMDPLR *pppm_dplr = (PPPMDPLR *)force->kspace_match("pppm/dplr", 1);
+  int nlocal = atom->nlocal;
+  int nghost = atom->nghost;
+  int nall = nlocal + nghost;
+  vector<FLOAT_PREC> dcoord(nall * 3, 0.0), dbox(9, 0.0),
+      dfele(nlocal * 3, 0.0);
+  vector<int> dtype(nall, 0);
+  // set values for dcoord, dbox, dfele
+  {
+    int *type = atom->type;
+    for (int ii = 0; ii < nall; ++ii) {
+      dtype[ii] = type_idx_map[type[ii] - 1];
+    }
+    dbox[0] = domain->h[0] / dist_unit_cvt_factor;  // xx
+    dbox[4] = domain->h[1] / dist_unit_cvt_factor;  // yy
+    dbox[8] = domain->h[2] / dist_unit_cvt_factor;  // zz
+    dbox[7] = domain->h[3] / dist_unit_cvt_factor;  // zy
+    dbox[6] = domain->h[4] / dist_unit_cvt_factor;  // zx
+    dbox[3] = domain->h[5] / dist_unit_cvt_factor;  // yx
+    // get coord
+    double **x = atom->x;
+    for (int ii = 0; ii < nall; ++ii) {
+      for (int dd = 0; dd < 3; ++dd) {
+        dcoord[ii * 3 + dd] =
+            (x[ii][dd] - domain->boxlo[dd]) / dist_unit_cvt_factor;
+      }
+    }
+    // revise force according to efield
+    if (pppm_dplr) {
+      const vector<double> &dfele_(pppm_dplr->get_fele());
+      assert(dfele_.size() == nlocal * 3);
+      for (int ii = 0; ii < nlocal * 3; ++ii) {
+        dfele[ii] += dfele_[ii];
+      }
+    }
+    // revise force and virial according to efield
+    double *q = atom->q;
+    imageint *image = atom->image;
+    double unwrap[3];
+    double v[6];
+    efield_fsum[0] = efield_fsum[1] = efield_fsum[2] = efield_fsum[3] = 0.0;
+    efield_force_flag = 0;
+    for (int ii = 0; ii < nlocal; ++ii) {
+      double tmpf[3];
+      for (int dd = 0; dd < 3; ++dd) {
+        tmpf[dd] = q[ii] * efield[dd] * force->qe2f;
+      }
+      for (int dd = 0; dd < 3; ++dd) {
+        dfele[ii * 3 + dd] += tmpf[dd];
+      }
+      domain->unmap(x[ii], image[ii], unwrap);
+      efield_fsum[0] -=
+          tmpf[0] * unwrap[0] + tmpf[1] * unwrap[1] + tmpf[2] * unwrap[2];
+      efield_fsum[1] += tmpf[0];
+      efield_fsum[2] += tmpf[1];
+      efield_fsum[3] += tmpf[2];
+      if (evflag) {
+        v[0] = tmpf[0] * unwrap[0];
+        v[1] = tmpf[1] * unwrap[1];
+        v[2] = tmpf[2] * unwrap[2];
+        v[3] = tmpf[0] * unwrap[1];
+        v[4] = tmpf[0] * unwrap[2];
+        v[5] = tmpf[1] * unwrap[2];
+        v_tally(ii, v);
+      }
+    }
+  }
+  // lmp nlist
+  NeighList *list = pair_deepmd->list;
+  deepmd_compat::InputNlist lmp_list(list->inum, list->ilist, list->numneigh,
+                                     list->firstneigh);
+  // bonded pairs
+  vector<pair<int, int> > valid_pairs;
+  get_valid_pairs(valid_pairs);
+  // output vects
+  vector<FLOAT_PREC> dfcorr, dvcorr;
+  // compute
+  try {
+    for (int ii = 0; ii < nlocal * 3; ++ii) {
+      dfele[ii] /= force_unit_cvt_factor;
+    }
+    dtm.compute(dfcorr, dvcorr, dcoord, dtype, dbox, valid_pairs, dfele, nghost,
+                lmp_list);
+    for (int ii = 0; ii < nlocal * 3; ++ii) {
+      dfcorr[ii] *= force_unit_cvt_factor;
+    }
+    for (int ii = 0; ii < 9; ++ii) {
+      dvcorr[ii] *= ener_unit_cvt_factor;
+    }
+  } catch (deepmd_compat::deepmd_exception &e) {
+    error->one(FLERR, e.what());
+  }
+  assert(dfcorr.size() == dcoord.size());
+  assert(dfcorr.size() == nall * 3);
+  // backward communication of fcorr
+  dfcorr_buff.resize(dfcorr.size());
+  copy(dfcorr.begin(), dfcorr.end(), dfcorr_buff.begin());
+#if LAMMPS_VERSION_NUMBER >= 20220324
+  comm->reverse_comm(this, 3);
+#else
+  comm->reverse_comm_fix(this, 3);
+#endif
+  copy(dfcorr_buff.begin(), dfcorr_buff.end(), dfcorr.begin());
+  // // check and print
+  // cout << "-------------------- fix/dplr: post force " << endl;
+  // cout << "dfcorr.size() " << dfcorr.size() << endl;
+  // cout << "dcoord.size() " << dcoord.size() << endl;
+  // for (int ii = 0; ii < nlocal; ++ii){
+  //   cout << ii << "\t x: ";
+  //   for (int dd = 0; dd < 3; ++dd){
+  //     cout << dcoord[ii*3+dd] << " \t " ;
+  //   }
+  //   cout << ii << "\t f: ";
+  //   for (int dd = 0; dd < 3; ++dd){
+  //     cout << dfcorr[ii*3+dd] << " \t " ;
+  //   }
+  //   cout << endl;
+  // }
+  // apply the force correction
+  double **f = atom->f;
+  for (int ii = 0; ii < nlocal; ++ii) {
+    for (int dd = 0; dd < 3; ++dd) {
+      f[ii][dd] += dfcorr[ii * 3 + dd];
+    }
+  }
+  // cout << "virial corr1 ";
+  // for (int ii = 0; ii < 9; ++ii){
+  //   cout << dvcorr[ii] << " " ;
+  // }
+  // cout << endl;
+  for (int ii = 0; ii < valid_pairs.size(); ++ii) {
+    int idx0 = valid_pairs[ii].first;
+    int idx1 = valid_pairs[ii].second;
+    for (int dd0 = 0; dd0 < 3; ++dd0) {
+      for (int dd1 = 0; dd1 < 3; ++dd1) {
+        dvcorr[dd0 * 3 + dd1] -=
+            dfele[idx1 * 3 + dd0] * dipole_recd[idx0 * 3 + dd1];
+      }
+    }
+  }
+  // cout << "virial corr2 ";
+  // for (int ii = 0; ii < 9; ++ii){
+  //   cout << dvcorr[ii] << " " ;
+  // }
+  // cout << endl;
+  if (evflag) {
+    double vv[6] = {0.0};
+    vv[0] += dvcorr[0];
+    vv[1] += dvcorr[4];
+    vv[2] += dvcorr[8];
+    vv[3] += dvcorr[3];
+    vv[4] += dvcorr[6];
+    vv[5] += dvcorr[7];
+    v_tally(0, vv);
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::min_pre_exchange() { post_integrate(); }
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::min_pre_force(int vflag) { pre_force(vflag); }
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::min_post_force(int vflag) { post_force(vflag); }
+
+/* ---------------------------------------------------------------------- */
+
+int FixDPLR::pack_reverse_comm(int n, int first, double *buf) {
+  int m = 0;
+  int last = first + n;
+  for (int i = first; i < last; i++) {
+    buf[m++] = dfcorr_buff[3 * i + 0];
+    buf[m++] = dfcorr_buff[3 * i + 1];
+    buf[m++] = dfcorr_buff[3 * i + 2];
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixDPLR::unpack_reverse_comm(int n, int *list, double *buf) {
+  int m = 0;
+  for (int i = 0; i < n; i++) {
+    int j = list[i];
+    dfcorr_buff[3 * j + 0] += buf[m++];
+    dfcorr_buff[3 * j + 1] += buf[m++];
+    dfcorr_buff[3 * j + 2] += buf[m++];
+  }
+}
+
+/* ----------------------------------------------------------------------
+   return energy added by fix
+------------------------------------------------------------------------- */
+
+double FixDPLR::compute_scalar(void) {
+  if (efield_force_flag == 0) {
+    MPI_Allreduce(&efield_fsum[0], &efield_fsum_all[0], 4, MPI_DOUBLE, MPI_SUM,
+                  world);
+    efield_force_flag = 1;
+  }
+  return efield_fsum_all[0];
+}
+
+/* ----------------------------------------------------------------------
+   return total extra force due to fix
+------------------------------------------------------------------------- */
+
+double FixDPLR::compute_vector(int n) {
+  if (efield_force_flag == 0) {
+    MPI_Allreduce(&efield_fsum[0], &efield_fsum_all[0], 4, MPI_DOUBLE, MPI_SUM,
+                  world);
+    efield_force_flag = 1;
+  }
+  return efield_fsum_all[n + 1];
+}
+
+/* ----------------------------------------------------------------------
+   update efield variables without doing anything else
+------------------------------------------------------------------------- */
+
+void FixDPLR::update_efield_variables() {
+  modify->clearstep_compute();
+
+  if (xstyle == EQUAL) {
+    efield[0] = qe2f * input->variable->compute_equal(xvar);
+  }
+  if (ystyle == EQUAL) {
+    efield[1] = qe2f * input->variable->compute_equal(yvar);
+  }
+  if (zstyle == EQUAL) {
+    efield[2] = qe2f * input->variable->compute_equal(zvar);
+  }
+
+  modify->addstep_compute(update->ntimestep + 1);
+}
diff --git a/src/USER-DEEPMD/fix_dplr.h b/src/USER-DEEPMD/fix_dplr.h
new file mode 100644
index 0000000000..a6822fe4fe
--- /dev/null
+++ b/src/USER-DEEPMD/fix_dplr.h
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: LGPL-3.0-or-later
+#ifdef FIX_CLASS
+
+FixStyle(dplr, FixDPLR)
+
+#else
+
+#ifndef LMP_FIX_DPLR_H
+#define LMP_FIX_DPLR_H
+
+#include <stdio.h>
+
+#include <map>
+
+#include "fix.h"
+#include "pair_deepmd.h"
+#ifdef DP_USE_CXX_API
+#ifdef LMPPLUGIN
+#include "DataModifier.h"
+#include "DeepTensor.h"
+#else
+#include "deepmd/DataModifier.h"
+#include "deepmd/DeepTensor.h"
+#endif
+namespace deepmd_compat = deepmd;
+#else
+#ifdef LMPPLUGIN
+#include "deepmd.hpp"
+#else
+#include "deepmd/deepmd.hpp"
+#endif
+namespace deepmd_compat = deepmd::hpp;
+#endif
+
+#define FLOAT_PREC double
+
+namespace LAMMPS_NS {
+class FixDPLR : public Fix {
+ public:
+  FixDPLR(class LAMMPS *, int, char **);
+  ~FixDPLR() override;
+  int setmask() override;
+  void init() override;
+  void setup(int) override;
+  void setup_pre_force(int) override;
+  void min_setup(int) override;
+  void post_integrate() override;
+  void pre_force(int) override;
+  void post_force(int) override;
+  void min_pre_exchange() override;
+  void min_pre_force(int) override;
+  void min_post_force(int) override;
+  int pack_reverse_comm(int, int, double *) override;
+  void unpack_reverse_comm(int, int *, double *) override;
+  double compute_scalar(void) override;
+  double compute_vector(int) override;
+  double ener_unit_cvt_factor, dist_unit_cvt_factor, force_unit_cvt_factor;
+
+ private:
+  PairDeepMD *pair_deepmd;
+  deepmd_compat::DeepTensor dpt;
+  deepmd_compat::DipoleChargeModifier dtm;
+  std::string model;
+  int ntypes;
+  std::vector<int> sel_type;
+  std::vector<int> dpl_type;
+  std::vector<int> bond_type;
+  std::map<int, int> type_asso;
+  std::map<int, int> bk_type_asso;
+  std::vector<FLOAT_PREC> dipole_recd;
+  std::vector<double> dfcorr_buff;
+  std::vector<double> efield;
+  std::vector<double> efield_fsum, efield_fsum_all;
+  int efield_force_flag;
+  void get_valid_pairs(std::vector<std::pair<int, int> > &pairs);
+  int varflag;
+  char *xstr, *ystr, *zstr;
+  int xvar, yvar, zvar, xstyle, ystyle, zstyle;
+  double qe2f;
+  void update_efield_variables();
+  enum { NONE, CONSTANT, EQUAL };
+  std::vector<int> type_idx_map;
+};
+}  // namespace LAMMPS_NS
+
+#endif  // LMP_FIX_DPLR_H
+#endif  // FIX_CLASS
diff --git a/src/USER-DEEPMD/fix_ttm_dp.h b/src/USER-DEEPMD/fix_ttm_dp.h
new file mode 100644
index 0000000000..168f880226
--- /dev/null
+++ b/src/USER-DEEPMD/fix_ttm_dp.h
@@ -0,0 +1,18 @@
+// SPDX-License-Identifier: LGPL-3.0-or-later
+#include <vector>
+
+#include "fix_ttm.h"
+
+namespace LAMMPS_NS {
+class FixTTMDP : public FixTTM {
+ public:
+  std::vector<int> get_nodes() const {
+    std::vector<int> tmp(3);
+    tmp[0] = nxgrid;
+    tmp[1] = nygrid;
+    tmp[2] = nzgrid;
+    return tmp;
+  };
+  double ***const get_T_electron() const { return T_electron; };
+};
+}  // namespace LAMMPS_NS
diff --git a/src/USER-DEEPMD/lmp_version.sh b/src/USER-DEEPMD/lmp_version.sh
new file mode 100755
index 0000000000..99c1c5552e
--- /dev/null
+++ b/src/USER-DEEPMD/lmp_version.sh
@@ -0,0 +1,9 @@
+#!/bin/sh
+set -e
+# Read LAMMPS version from version.h
+version_line=$(grep LAMMPS_VERSION ../version.h)
+# extract version
+tmp=${version_line#*\"} # remove prefix ending in "
+version=${tmp%\"*}      # remove suffix starting with "
+# string to int
+date --date="$(printf "$version")" +"%Y%m%d"
diff --git a/src/USER-DEEPMD/pair_deepmd.cpp b/src/USER-DEEPMD/pair_deepmd.cpp
new file mode 100644
index 0000000000..1a64fdb869
--- /dev/null
+++ b/src/USER-DEEPMD/pair_deepmd.cpp
@@ -0,0 +1,1540 @@
+// SPDX-License-Identifier: LGPL-3.0-or-later
+#include <string.h>
+
+#include <iomanip>
+#include <iostream>
+#include <limits>
+#include <map>
+#include <sstream>
+
+#include "atom.h"
+#include "citeme.h"
+#include "comm.h"
+#include "compute.h"
+#include "domain.h"
+#include "error.h"
+#include "fix.h"
+#include "force.h"
+#include "memory.h"
+#include "modify.h"
+#include "neigh_list.h"
+#include "neigh_request.h"
+#include "neighbor.h"
+#include "output.h"
+#include "update.h"
+#if LAMMPS_VERSION_NUMBER >= 20210831
+// in lammps #2902, fix_ttm members turns from private to protected
+#define USE_TTM 1
+#include "fix_ttm_dp.h"
+#endif
+
+#include "deepmd_version.h"
+#include "pair_deepmd.h"
+
+using namespace LAMMPS_NS;
+using namespace std;
+
+static const char cite_user_deepmd_package[] =
+    "USER-DEEPMD package:\n\n"
+    "@article{Wang_ComputPhysCommun_2018_v228_p178,\n"
+    "  author = {Wang, Han and Zhang, Linfeng and Han, Jiequn and E, Weinan},\n"
+    "  doi = {10.1016/j.cpc.2018.03.016},\n"
+    "  url = {https://doi.org/10.1016/j.cpc.2018.03.016},\n"
+    "  year = 2018,\n"
+    "  month = {jul},\n"
+    "  publisher = {Elsevier {BV}},\n"
+    "  volume = 228,\n"
+    "  journal = {Comput. Phys. Commun.},\n"
+    "  title = {{DeePMD-kit: A deep learning package for many-body potential "
+    "energy representation and molecular dynamics}},\n"
+    "  pages = {178--184}\n"
+    "}\n"
+    "@misc{Zeng_JChemPhys_2023_v159_p054801,\n"
+    "  title  = {{DeePMD-kit v2: A software package for deep potential "
+    "models}},\n"
+    "  author =   {Jinzhe Zeng and Duo Zhang and Denghui Lu and Pinghui Mo and "
+    "Zeyu Li\n"
+    "         and Yixiao Chen and Mari{\\'a}n Rynik and Li'ang Huang and Ziyao "
+    "Li and \n"
+    "         Shaochen Shi and Yingze Wang and Haotian Ye and Ping Tuo and "
+    "Jiabin\n"
+    "         Yang and Ye Ding and Yifan Li and Davide Tisi and Qiyu Zeng and "
+    "Han \n"
+    "         Bao and Yu Xia and Jiameng Huang and Koki Muraoka and Yibo Wang "
+    "and \n"
+    "         Junhan Chang and Fengbo Yuan and Sigbj{\\o}rn L{\\o}land Bore "
+    "and "
+    "Chun\n"
+    "         Cai and Yinnian Lin and Bo Wang and Jiayan Xu and Jia-Xin Zhu "
+    "and \n"
+    "         Chenxing Luo and Yuzhi Zhang and Rhys E A Goodall and Wenshuo "
+    "Liang\n"
+    "         and Anurag Kumar Singh and Sikai Yao and Jingchao Zhang and "
+    "Renata\n"
+    "         Wentzcovitch and Jiequn Han and Jie Liu and Weile Jia and Darrin "
+    "M\n"
+    "         York and Weinan E and Roberto Car and Linfeng Zhang and Han "
+    "Wang},\n"
+    "  journal =  {J. Chem. Phys.},\n"
+    "  volume =   159,\n"
+    "  issue =    5,  \n"
+    "  year =    2023,\n"
+    "  pages  =   054801,\n"
+    "  doi =      {10.1063/5.0155600},\n"
+    "}\n\n";
+
+static int stringCmp(const void *a, const void *b) {
+  char *m = (char *)a;
+  char *n = (char *)b;
+  int i, sum = 0;
+
+  for (i = 0; i < MPI_MAX_PROCESSOR_NAME; i++) {
+    if (m[i] == n[i]) {
+      continue;
+    } else {
+      sum = m[i] - n[i];
+      break;
+    }
+  }
+  return sum;
+}
+
+int PairDeepMD::get_node_rank() {
+  char host_name[MPI_MAX_PROCESSOR_NAME];
+  memset(host_name, '\0', sizeof(char) * MPI_MAX_PROCESSOR_NAME);
+  char(*host_names)[MPI_MAX_PROCESSOR_NAME];
+  int n, namelen, color, rank, nprocs, myrank;
+  size_t bytes;
+  MPI_Comm nodeComm;
+
+  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
+  MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
+  MPI_Get_processor_name(host_name, &namelen);
+
+  bytes = nprocs * sizeof(char[MPI_MAX_PROCESSOR_NAME]);
+  host_names = (char(*)[MPI_MAX_PROCESSOR_NAME])malloc(bytes);
+  for (int ii = 0; ii < nprocs; ii++) {
+    memset(host_names[ii], '\0', sizeof(char) * MPI_MAX_PROCESSOR_NAME);
+  }
+
+  strcpy(host_names[rank], host_name);
+
+  for (n = 0; n < nprocs; n++) {
+    MPI_Bcast(&(host_names[n]), MPI_MAX_PROCESSOR_NAME, MPI_CHAR, n,
+              MPI_COMM_WORLD);
+  }
+  qsort(host_names, nprocs, sizeof(char[MPI_MAX_PROCESSOR_NAME]), stringCmp);
+
+  color = 0;
+  for (n = 0; n < nprocs - 1; n++) {
+    if (strcmp(host_name, host_names[n]) == 0) {
+      break;
+    }
+    if (strcmp(host_names[n], host_names[n + 1])) {
+      color++;
+    }
+  }
+
+  MPI_Comm_split(MPI_COMM_WORLD, color, 0, &nodeComm);
+  MPI_Comm_rank(nodeComm, &myrank);
+
+  MPI_Barrier(MPI_COMM_WORLD);
+  int looprank = myrank;
+  // printf (" Assigning device %d  to process on node %s rank %d,
+  // OK\n",looprank,  host_name, rank );
+  free(host_names);
+  return looprank;
+}
+
+std::string PairDeepMD::get_file_content(const std::string &model) {
+  int myrank = 0, root = 0;
+  MPI_Comm_rank(MPI_COMM_WORLD, &myrank);
+  int nchar = 0;
+  std::string file_content;
+  if (myrank == root) {
+    deepmd_compat::read_file_to_string(model, file_content);
+    nchar = file_content.size();
+  }
+  MPI_Bcast(&nchar, 1, MPI_INT, root, MPI_COMM_WORLD);
+  char *buff = (char *)malloc(sizeof(char) * nchar);
+  if (myrank == root) {
+    memcpy(buff, file_content.c_str(), sizeof(char) * nchar);
+  }
+  MPI_Bcast(buff, nchar, MPI_CHAR, root, MPI_COMM_WORLD);
+  file_content.resize(nchar);
+  for (unsigned ii = 0; ii < nchar; ++ii) {
+    file_content[ii] = buff[ii];
+  }
+  free(buff);
+  return file_content;
+}
+
+std::vector<std::string> PairDeepMD::get_file_content(
+    const std::vector<std::string> &models) {
+  std::vector<std::string> file_contents(models.size());
+  for (unsigned ii = 0; ii < models.size(); ++ii) {
+    file_contents[ii] = get_file_content(models[ii]);
+  }
+  return file_contents;
+}
+
+static void ana_st(double &max,
+                   double &min,
+                   double &sum,
+                   const vector<double> &vec,
+                   const int &nloc) {
+  if (nloc == 0) {
+    return;
+  }
+  max = vec[0];
+  min = vec[0];
+  sum = vec[0];
+  for (unsigned ii = 1; ii < nloc; ++ii) {
+    if (vec[ii] > max) {
+      max = vec[ii];
+    }
+    if (vec[ii] < min) {
+      min = vec[ii];
+    }
+    sum += vec[ii];
+  }
+}
+
+static void make_uniform_aparam(vector<double> &daparam,
+                                const vector<double> &aparam,
+                                const int &nlocal) {
+  unsigned dim_aparam = aparam.size();
+  daparam.resize(static_cast<size_t>(dim_aparam) * nlocal);
+  for (int ii = 0; ii < nlocal; ++ii) {
+    for (int jj = 0; jj < dim_aparam; ++jj) {
+      daparam[ii * dim_aparam + jj] = aparam[jj];
+    }
+  }
+}
+
+void PairDeepMD::make_fparam_from_compute(vector<double> &fparam) {
+  assert(do_compute_fparam);
+
+  int icompute = modify->find_compute(compute_fparam_id);
+  Compute *compute = modify->compute[icompute];
+
+  if (!compute) {
+    error->all(FLERR, "compute id is not found: " + compute_fparam_id);
+  }
+  fparam.resize(dim_fparam);
+
+  if (dim_fparam == 1) {
+    if (!(compute->invoked_flag & Compute::INVOKED_SCALAR)) {
+      compute->compute_scalar();
+      compute->invoked_flag |= Compute::INVOKED_SCALAR;
+    }
+    fparam[0] = compute->scalar;
+  } else if (dim_fparam > 1) {
+    if (!(compute->invoked_flag & Compute::INVOKED_VECTOR)) {
+      compute->compute_vector();
+      compute->invoked_flag |= Compute::INVOKED_VECTOR;
+    }
+    double *cvector = compute->vector;
+    for (int jj = 0; jj < dim_fparam; ++jj) {
+      fparam[jj] = cvector[jj];
+    }
+  }
+}
+
+void PairDeepMD::make_aparam_from_compute(vector<double> &aparam) {
+  assert(do_compute_aparam);
+
+  int icompute = modify->find_compute(compute_aparam_id);
+  Compute *compute = modify->compute[icompute];
+
+  if (!compute) {
+    error->all(FLERR, "compute id is not found: " + compute_aparam_id);
+  }
+  int nlocal = atom->nlocal;
+  aparam.resize(static_cast<size_t>(dim_aparam) * nlocal);
+
+  if (!(compute->invoked_flag & Compute::INVOKED_PERATOM)) {
+    compute->compute_peratom();
+    compute->invoked_flag |= Compute::INVOKED_PERATOM;
+  }
+  if (dim_aparam == 1) {
+    double *cvector = compute->vector_atom;
+    aparam.assign(cvector, cvector + nlocal);
+  } else if (dim_aparam > 1) {
+    double **carray = compute->array_atom;
+    for (int ii = 0; ii < nlocal; ++ii) {
+      for (int jj = 0; jj < dim_aparam; ++jj) {
+        aparam[ii * dim_aparam + jj] = carray[ii][jj];
+      }
+    }
+  }
+}
+
+#ifdef USE_TTM
+void PairDeepMD::make_ttm_fparam(vector<double> &fparam) {
+  assert(do_ttm);
+  // get ttm_fix
+  const FixTTMDP *ttm_fix = NULL;
+  for (int ii = 0; ii < modify->nfix; ii++) {
+    if (string(modify->fix[ii]->id) == ttm_fix_id) {
+      ttm_fix = dynamic_cast<FixTTMDP *>(modify->fix[ii]);
+    }
+  }
+  if (!ttm_fix) {
+    error->all(FLERR, "fix ttm id is not found: " + ttm_fix_id);
+  }
+
+  fparam.resize(dim_fparam);
+
+  vector<int> nnodes = ttm_fix->get_nodes();
+  int nxnodes = nnodes[0];
+  int nynodes = nnodes[1];
+  int nznodes = nnodes[2];
+  double ***const T_electron = ttm_fix->get_T_electron();
+
+  int numb_effective_nodes = 0;
+  double total_Te = 0;
+
+  // loop over grids to get average electron temperature
+  for (int ixnode = 0; ixnode < nxnodes; ixnode++) {
+    for (int iynode = 0; iynode < nynodes; iynode++) {
+      for (int iznode = 0; iznode < nznodes; iznode++) {
+        if (T_electron[ixnode][iynode][iznode] != 0) {
+          numb_effective_nodes += 1;
+          total_Te += T_electron[ixnode][iynode][iznode];
+        }
+      }
+    }
+  }
+
+  fparam[0] = total_Te / numb_effective_nodes;
+}
+#endif
+
+#ifdef USE_TTM
+void PairDeepMD::make_ttm_aparam(vector<double> &daparam) {
+  assert(do_ttm);
+  // get ttm_fix
+  const FixTTMDP *ttm_fix = NULL;
+  for (int ii = 0; ii < modify->nfix; ii++) {
+    if (string(modify->fix[ii]->id) == ttm_fix_id) {
+      ttm_fix = dynamic_cast<FixTTMDP *>(modify->fix[ii]);
+    }
+  }
+  if (!ttm_fix) {
+    error->all(FLERR, "fix ttm id is not found: " + ttm_fix_id);
+  }
+  // modify
+  double **x = atom->x;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  vector<int> nnodes = ttm_fix->get_nodes();
+  int nxnodes = nnodes[0];
+  int nynodes = nnodes[1];
+  int nznodes = nnodes[2];
+  double ***const T_electron = ttm_fix->get_T_electron();
+  double dx = domain->xprd / nxnodes;
+  double dy = domain->yprd / nynodes;
+  double dz = domain->zprd / nynodes;
+  // resize daparam
+  daparam.resize(nlocal);
+  // loop over atoms to assign aparam
+  for (int ii = 0; ii < nlocal; ii++) {
+    if (mask[ii] & ttm_fix->groupbit) {
+      double xscale = (x[ii][0] - domain->boxlo[0]) / domain->xprd;
+      double yscale = (x[ii][1] - domain->boxlo[1]) / domain->yprd;
+      double zscale = (x[ii][2] - domain->boxlo[2]) / domain->zprd;
+      int ixnode = static_cast<int>(xscale * nxnodes);
+      int iynode = static_cast<int>(yscale * nynodes);
+      int iznode = static_cast<int>(zscale * nznodes);
+      // https://stackoverflow.com/a/1907585/9567349
+      ixnode = ((ixnode % nxnodes) + nxnodes) % nxnodes;
+      iynode = ((iynode % nynodes) + nynodes) % nynodes;
+      iznode = ((iznode % nznodes) + nznodes) % nznodes;
+      daparam[ii] = T_electron[ixnode][iynode][iznode];
+    }
+  }
+}
+#endif
+
+void PairDeepMD::cum_sum(std::map<int, int> &sum, std::map<int, int> &vec) {
+  sum[0] = 0;
+  for (int ii = 1; ii < vec.size(); ++ii) {
+    sum[ii] = sum[ii - 1] + vec[ii - 1];
+  }
+}
+
+PairDeepMD::PairDeepMD(LAMMPS *lmp)
+    : Pair(lmp)
+
+{
+  if (lmp->citeme) {
+    lmp->citeme->add(cite_user_deepmd_package);
+  }
+  if (strcmp(update->unit_style, "lj") == 0) {
+    error->all(FLERR,
+               "Pair deepmd does not support unit style lj. Please use other "
+               "unit styles like metal or real unit instead. You may set it by "
+               "\"units metal\" or \"units real\"");
+  }
+  ener_unit_cvt_factor = force->boltz / 8.617343e-5;
+  dist_unit_cvt_factor = force->angstrom;
+  force_unit_cvt_factor = ener_unit_cvt_factor / dist_unit_cvt_factor;
+
+  restartinfo = 1;
+#if LAMMPS_VERSION_NUMBER >= 20201130
+  centroidstressflag =
+      CENTROID_AVAIL;  // set centroidstressflag = CENTROID_AVAIL to allow the
+                       // use of the centroid/stress/atom. Added by Davide Tisi
+#else
+  centroidstressflag = 2;  // set centroidstressflag = 2 to allow the use of the
+                           // centroid/stress/atom. Added by Davide Tisi
+#endif
+  pppmflag = 1;
+  respa_enable = 0;
+  writedata = 0;
+
+  cutoff = 0.;
+  numb_types = 0;
+  numb_types_spin = 0;
+  numb_models = 0;
+  out_freq = 0;
+  out_each = 0;
+  out_rel = 0;
+  out_rel_v = 0;
+  stdf_comm_buff_size = 0;
+  eps = 0.;
+  eps_v = 0.;
+  scale = NULL;
+  do_ttm = false;
+  do_compute_fparam = false;
+  do_compute_aparam = false;
+  single_model = false;
+  multi_models_mod_devi = false;
+  multi_models_no_mod_devi = false;
+  is_restart = false;
+  // set comm size needed by this Pair
+  comm_reverse = 1;
+
+  print_summary("  ");
+}
+
+void PairDeepMD::print_summary(const string pre) const {
+  if (comm->me == 0) {
+    // capture cout to a string, then call LAMMPS's utils::logmesg
+    // https://stackoverflow.com/a/4043813/9567349
+    std::stringstream buffer;
+    std::streambuf *sbuf = std::cout.rdbuf();
+    std::cout.rdbuf(buffer.rdbuf());
+
+    cout << "Summary of lammps deepmd module ..." << endl;
+    cout << pre << ">>> Info of deepmd-kit:" << endl;
+    deep_pot.print_summary(pre);
+    cout << pre << ">>> Info of lammps module:" << endl;
+    cout << pre << "use deepmd-kit at:  " << STR_DEEPMD_ROOT << endl;
+    cout << pre << "source:             " << STR_GIT_SUMM << endl;
+    cout << pre << "source branch:      " << STR_GIT_BRANCH << endl;
+    cout << pre << "source commit:      " << STR_GIT_HASH << endl;
+    cout << pre << "source commit at:   " << STR_GIT_DATE << endl;
+    cout << pre << "build float prec:   " << STR_FLOAT_PREC << endl;
+    cout << pre << "build with tf inc:  " << STR_TensorFlow_INCLUDE_DIRS
+         << endl;
+    cout << pre << "build with tf lib:  " << STR_TensorFlow_LIBRARY << endl;
+
+    std::cout.rdbuf(sbuf);
+    utils::logmesg(lmp, buffer.str());
+  }
+}
+
+PairDeepMD::~PairDeepMD() {
+  if (allocated) {
+    memory->destroy(setflag);
+    memory->destroy(cutsq);
+    memory->destroy(scale);
+  }
+}
+
+void PairDeepMD::compute(int eflag, int vflag) {
+  if (numb_models == 0) {
+    return;
+  }
+  // See
+  // https://docs.lammps.org/Developer_updating.html#use-ev-init-to-initialize-variables-derived-from-eflag-and-vflag
+  ev_init(eflag, vflag);
+  if (vflag_atom) {
+    error->all(FLERR,
+               "6-element atomic virial is not supported. Use compute "
+               "centroid/stress/atom command for 9-element atomic virial.");
+  }
+  bool do_ghost = true;
+
+  double **x = atom->x;
+  double **f = atom->f;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  int nghost = 0;
+  if (do_ghost) {
+    nghost = atom->nghost;
+  }
+  int nall = nlocal + nghost;
+  int newton_pair = force->newton_pair;
+
+  vector<double> dspin(nall * 3, 0.);
+  vector<double> dfm(nall * 3, 0.);
+  double **sp = atom->sp;
+  double **fm = atom->fm;
+  // spin initialize
+  if (atom->sp_flag) {
+    // get spin
+    for (int ii = 0; ii < nall; ++ii) {
+      for (int dd = 0; dd < 3; ++dd) {
+        dspin[ii * 3 + dd] = sp[ii][dd];
+      }
+    }
+  }
+
+  vector<int> dtype(nall);
+  for (int ii = 0; ii < nall; ++ii) {
+    dtype[ii] = type_idx_map[type[ii] - 1];
+  }
+
+  double dener(0);
+  vector<double> dforce(nall * 3);
+  vector<double> dvirial(9, 0);
+  vector<double> dcoord(nall * 3, 0.);
+  vector<double> dbox(9, 0);
+  vector<double> daparam;
+
+  // get box
+  dbox[0] = domain->h[0] / dist_unit_cvt_factor;  // xx
+  dbox[4] = domain->h[1] / dist_unit_cvt_factor;  // yy
+  dbox[8] = domain->h[2] / dist_unit_cvt_factor;  // zz
+  dbox[7] = domain->h[3] / dist_unit_cvt_factor;  // zy
+  dbox[6] = domain->h[4] / dist_unit_cvt_factor;  // zx
+  dbox[3] = domain->h[5] / dist_unit_cvt_factor;  // yx
+
+  // get coord
+  for (int ii = 0; ii < nall; ++ii) {
+    for (int dd = 0; dd < 3; ++dd) {
+      dcoord[ii * 3 + dd] =
+          (x[ii][dd] - domain->boxlo[dd]) / dist_unit_cvt_factor;
+    }
+  }
+
+  if (do_compute_aparam) {
+    make_aparam_from_compute(daparam);
+  } else if (aparam.size() > 0) {
+    // uniform aparam
+    make_uniform_aparam(daparam, aparam, nlocal);
+  } else if (do_ttm) {
+#ifdef USE_TTM
+    if (dim_aparam > 0) {
+      make_ttm_aparam(daparam);
+    } else if (dim_fparam > 0) {
+      make_ttm_fparam(fparam);
+    }
+#endif
+  }
+
+  if (do_compute_fparam) {
+    make_fparam_from_compute(fparam);
+  }
+
+  // int ago = numb_models > 1 ? 0 : neighbor->ago;
+  int ago = neighbor->ago;
+  if (numb_models > 1) {
+    if (multi_models_no_mod_devi &&
+        (out_freq > 0 && update->ntimestep % out_freq == 0)) {
+      ago = 0;
+    } else if (multi_models_mod_devi &&
+               (out_freq == 0 || update->ntimestep % out_freq != 0)) {
+      ago = 0;
+    }
+  }
+  // compute
+  single_model = (numb_models == 1);
+  multi_models_no_mod_devi =
+      (numb_models > 1 && (out_freq == 0 || update->ntimestep % out_freq != 0));
+  multi_models_mod_devi =
+      (numb_models > 1 && (out_freq > 0 && update->ntimestep % out_freq == 0));
+  if (do_ghost) {
+    deepmd_compat::InputNlist lmp_list(list->inum, list->ilist, list->numneigh,
+                                       list->firstneigh);
+    deepmd_compat::InputNlist extend_lmp_list;
+    if (atom->sp_flag) {
+      extend(extend_inum, extend_ilist, extend_numneigh, extend_neigh,
+             extend_firstneigh, extend_dcoord, extend_dtype, extend_nghost,
+             new_idx_map, old_idx_map, lmp_list, dcoord, dtype, nghost, dspin,
+             numb_types, numb_types_spin, virtual_len);
+      extend_lmp_list =
+          deepmd_compat::InputNlist(extend_inum, &extend_ilist[0],
+                                    &extend_numneigh[0], &extend_firstneigh[0]);
+    }
+    if (single_model || multi_models_no_mod_devi) {
+      // cvflag_atom is the right flag for the cvatom matrix
+      if (!(eflag_atom || cvflag_atom)) {
+        if (!atom->sp_flag) {
+          try {
+            deep_pot.compute(dener, dforce, dvirial, dcoord, dtype, dbox,
+                             nghost, lmp_list, ago, fparam, daparam);
+          } catch (deepmd_compat::deepmd_exception &e) {
+            error->one(FLERR, e.what());
+          }
+        } else {
+          dforce.resize(static_cast<size_t>(extend_inum + extend_nghost) * 3);
+          try {
+            deep_pot.compute(dener, dforce, dvirial, extend_dcoord,
+                             extend_dtype, dbox, extend_nghost, extend_lmp_list,
+                             ago, fparam, daparam);
+          } catch (deepmd_compat::deepmd_exception &e) {
+            error->one(FLERR, e.what());
+          }
+        }
+      }
+      // do atomic energy and virial
+      else {
+        vector<double> deatom(nall * 1, 0);
+        vector<double> dvatom(nall * 9, 0);
+        if (!atom->sp_flag) {
+          try {
+            deep_pot.compute(dener, dforce, dvirial, deatom, dvatom, dcoord,
+                             dtype, dbox, nghost, lmp_list, ago, fparam,
+                             daparam);
+          } catch (deepmd_compat::deepmd_exception &e) {
+            error->one(FLERR, e.what());
+          }
+        } else {
+          dforce.resize(static_cast<size_t>(extend_inum + extend_nghost) * 3);
+          try {
+            deep_pot.compute(dener, dforce, dvirial, extend_dcoord,
+                             extend_dtype, dbox, extend_nghost, extend_lmp_list,
+                             ago, fparam, daparam);
+          } catch (deepmd_compat::deepmd_exception &e) {
+            error->one(FLERR, e.what());
+          }
+        }
+        if (eflag_atom) {
+          for (int ii = 0; ii < nlocal; ++ii) {
+            eatom[ii] += scale[1][1] * deatom[ii] * ener_unit_cvt_factor;
+          }
+        }
+        // Added by Davide Tisi 2020
+        // interface the atomic virial computed by DeepMD
+        // with the one used in centroid atoms
+        if (cvflag_atom) {
+          for (int ii = 0; ii < nall; ++ii) {
+            // vatom[ii][0] += 1.0 * dvatom[9*ii+0];
+            // vatom[ii][1] += 1.0 * dvatom[9*ii+4];
+            // vatom[ii][2] += 1.0 * dvatom[9*ii+8];
+            // vatom[ii][3] += 1.0 * dvatom[9*ii+3];
+            // vatom[ii][4] += 1.0 * dvatom[9*ii+6];
+            // vatom[ii][5] += 1.0 * dvatom[9*ii+7];
+            cvatom[ii][0] +=
+                scale[1][1] * dvatom[9 * ii + 0] * ener_unit_cvt_factor;  // xx
+            cvatom[ii][1] +=
+                scale[1][1] * dvatom[9 * ii + 4] * ener_unit_cvt_factor;  // yy
+            cvatom[ii][2] +=
+                scale[1][1] * dvatom[9 * ii + 8] * ener_unit_cvt_factor;  // zz
+            cvatom[ii][3] +=
+                scale[1][1] * dvatom[9 * ii + 3] * ener_unit_cvt_factor;  // xy
+            cvatom[ii][4] +=
+                scale[1][1] * dvatom[9 * ii + 6] * ener_unit_cvt_factor;  // xz
+            cvatom[ii][5] +=
+                scale[1][1] * dvatom[9 * ii + 7] * ener_unit_cvt_factor;  // yz
+            cvatom[ii][6] +=
+                scale[1][1] * dvatom[9 * ii + 1] * ener_unit_cvt_factor;  // yx
+            cvatom[ii][7] +=
+                scale[1][1] * dvatom[9 * ii + 2] * ener_unit_cvt_factor;  // zx
+            cvatom[ii][8] +=
+                scale[1][1] * dvatom[9 * ii + 5] * ener_unit_cvt_factor;  // zy
+          }
+        }
+      }
+    } else if (multi_models_mod_devi) {
+      vector<double> deatom(nall * 1, 0);
+      vector<double> dvatom(nall * 9, 0);
+      vector<vector<double>> all_virial;
+      vector<double> all_energy;
+      vector<vector<double>> all_atom_energy;
+      vector<vector<double>> all_atom_virial;
+      try {
+        deep_pot_model_devi.compute(
+            all_energy, all_force, all_virial, all_atom_energy, all_atom_virial,
+            dcoord, dtype, dbox, nghost, lmp_list, ago, fparam, daparam);
+      } catch (deepmd_compat::deepmd_exception &e) {
+        error->one(FLERR, e.what());
+      }
+      // deep_pot_model_devi.compute_avg (dener, all_energy);
+      // deep_pot_model_devi.compute_avg (dforce, all_force);
+      // deep_pot_model_devi.compute_avg (dvirial, all_virial);
+      // deep_pot_model_devi.compute_avg (deatom, all_atom_energy);
+      // deep_pot_model_devi.compute_avg (dvatom, all_atom_virial);
+      dener = all_energy[0];
+      dforce = all_force[0];
+      dvirial = all_virial[0];
+      deatom = all_atom_energy[0];
+      dvatom = all_atom_virial[0];
+      if (eflag_atom) {
+        for (int ii = 0; ii < nlocal; ++ii) {
+          eatom[ii] += scale[1][1] * deatom[ii] * ener_unit_cvt_factor;
+        }
+      }
+      // Added by Davide Tisi 2020
+      // interface the atomic virial computed by DeepMD
+      // with the one used in centroid atoms
+      if (cvflag_atom) {
+        for (int ii = 0; ii < nall; ++ii) {
+          // vatom[ii][0] += 1.0 * dvatom[9*ii+0];
+          // vatom[ii][1] += 1.0 * dvatom[9*ii+4];
+          // vatom[ii][2] += 1.0 * dvatom[9*ii+8];
+          // vatom[ii][3] += 1.0 * dvatom[9*ii+3];
+          // vatom[ii][4] += 1.0 * dvatom[9*ii+6];
+          // vatom[ii][5] += 1.0 * dvatom[9*ii+7];
+          cvatom[ii][0] +=
+              scale[1][1] * dvatom[9 * ii + 0] * ener_unit_cvt_factor;  // xx
+          cvatom[ii][1] +=
+              scale[1][1] * dvatom[9 * ii + 4] * ener_unit_cvt_factor;  // yy
+          cvatom[ii][2] +=
+              scale[1][1] * dvatom[9 * ii + 8] * ener_unit_cvt_factor;  // zz
+          cvatom[ii][3] +=
+              scale[1][1] * dvatom[9 * ii + 3] * ener_unit_cvt_factor;  // xy
+          cvatom[ii][4] +=
+              scale[1][1] * dvatom[9 * ii + 6] * ener_unit_cvt_factor;  // xz
+          cvatom[ii][5] +=
+              scale[1][1] * dvatom[9 * ii + 7] * ener_unit_cvt_factor;  // yz
+          cvatom[ii][6] +=
+              scale[1][1] * dvatom[9 * ii + 1] * ener_unit_cvt_factor;  // yx
+          cvatom[ii][7] +=
+              scale[1][1] * dvatom[9 * ii + 2] * ener_unit_cvt_factor;  // zx
+          cvatom[ii][8] +=
+              scale[1][1] * dvatom[9 * ii + 5] * ener_unit_cvt_factor;  // zy
+        }
+      }
+      if (out_freq > 0 && update->ntimestep % out_freq == 0) {
+        int rank = comm->me;
+        // std force
+        if (newton_pair) {
+#if LAMMPS_VERSION_NUMBER >= 20220324
+          comm->reverse_comm(this);
+#else
+          comm->reverse_comm_pair(this);
+#endif
+        }
+        vector<double> std_f;
+        vector<double> tmp_avg_f;
+        deep_pot_model_devi.compute_avg(tmp_avg_f, all_force);
+        deep_pot_model_devi.compute_std_f(std_f, tmp_avg_f, all_force);
+        if (out_rel == 1) {
+          deep_pot_model_devi.compute_relative_std_f(std_f, tmp_avg_f, eps);
+        }
+        double min = numeric_limits<double>::max(), max = 0, avg = 0;
+        ana_st(max, min, avg, std_f, nlocal);
+        double all_f_min = 0, all_f_max = 0, all_f_avg = 0;
+        MPI_Reduce(&min, &all_f_min, 1, MPI_DOUBLE, MPI_MIN, 0, world);
+        MPI_Reduce(&max, &all_f_max, 1, MPI_DOUBLE, MPI_MAX, 0, world);
+        MPI_Reduce(&avg, &all_f_avg, 1, MPI_DOUBLE, MPI_SUM, 0, world);
+        all_f_avg /= double(atom->natoms);
+        // std v
+        std::vector<double> send_v(9 * numb_models);
+        std::vector<double> recv_v(9 * numb_models);
+        for (int kk = 0; kk < numb_models; ++kk) {
+          for (int ii = 0; ii < 9; ++ii) {
+            send_v[kk * 9 + ii] = all_virial[kk][ii] / double(atom->natoms);
+          }
+        }
+        MPI_Reduce(&send_v[0], &recv_v[0], 9 * numb_models, MPI_DOUBLE, MPI_SUM,
+                   0, world);
+        std::vector<std::vector<double>> all_virial_1(numb_models);
+        std::vector<double> avg_virial, std_virial;
+        for (int kk = 0; kk < numb_models; ++kk) {
+          all_virial_1[kk].resize(9);
+          for (int ii = 0; ii < 9; ++ii) {
+            all_virial_1[kk][ii] = recv_v[kk * 9 + ii];
+          }
+        }
+        double all_v_min = numeric_limits<double>::max(), all_v_max = 0,
+               all_v_avg = 0;
+        if (rank == 0) {
+          deep_pot_model_devi.compute_avg(avg_virial, all_virial_1);
+          deep_pot_model_devi.compute_std(std_virial, avg_virial, all_virial_1,
+                                          1);
+          if (out_rel_v == 1) {
+            deep_pot_model_devi.compute_relative_std(std_virial, avg_virial,
+                                                     eps_v, 1);
+          }
+          for (int ii = 0; ii < 9; ++ii) {
+            if (std_virial[ii] > all_v_max) {
+              all_v_max = std_virial[ii];
+            }
+            if (std_virial[ii] < all_v_min) {
+              all_v_min = std_virial[ii];
+            }
+            all_v_avg += std_virial[ii] * std_virial[ii];
+          }
+          all_v_avg = sqrt(all_v_avg / 9);
+        }
+        if (rank == 0) {
+          all_v_max *= ener_unit_cvt_factor;
+          all_v_min *= ener_unit_cvt_factor;
+          all_v_avg *= ener_unit_cvt_factor;
+          all_f_max *= force_unit_cvt_factor;
+          all_f_min *= force_unit_cvt_factor;
+          all_f_avg *= force_unit_cvt_factor;
+          fp << setw(12) << update->ntimestep << " " << setw(18) << all_v_max
+             << " " << setw(18) << all_v_min << " " << setw(18) << all_v_avg
+             << " " << setw(18) << all_f_max << " " << setw(18) << all_f_min
+             << " " << setw(18) << all_f_avg;
+        }
+        if (out_each == 1) {
+          vector<double> std_f_all(atom->natoms);
+          // Gather std_f and tags
+          tagint *tag = atom->tag;
+          int nprocs = comm->nprocs;
+          // Grow arrays if necessary
+          if (atom->natoms > stdf_comm_buff_size) {
+            stdf_comm_buff_size = atom->natoms;
+            memory->destroy(stdfsend);
+            memory->destroy(stdfrecv);
+            memory->destroy(tagsend);
+            memory->destroy(tagrecv);
+            memory->create(stdfsend, stdf_comm_buff_size, "deepmd:stdfsendall");
+            memory->create(stdfrecv, stdf_comm_buff_size, "deepmd:stdfrecvall");
+            memory->create(tagsend, stdf_comm_buff_size, "deepmd:tagsendall");
+            memory->create(tagrecv, stdf_comm_buff_size, "deepmd:tagrecvall");
+          }
+          for (int ii = 0; ii < nlocal; ii++) {
+            tagsend[ii] = tag[ii];
+            stdfsend[ii] = std_f[ii];
+          }
+          MPI_Gather(&nlocal, 1, MPI_INT, counts, 1, MPI_INT, 0, world);
+          displacements[0] = 0;
+          for (int ii = 0; ii < nprocs - 1; ii++) {
+            displacements[ii + 1] = displacements[ii] + counts[ii];
+          }
+          MPI_Gatherv(tagsend, nlocal, MPI_LMP_TAGINT, tagrecv, counts,
+                      displacements, MPI_LMP_TAGINT, 0, world);
+          MPI_Gatherv(stdfsend, nlocal, MPI_DOUBLE, stdfrecv, counts,
+                      displacements, MPI_DOUBLE, 0, world);
+          if (rank == 0) {
+            for (int dd = 0; dd < atom->natoms; ++dd) {
+              std_f_all[tagrecv[dd] - 1] = stdfrecv[dd] * force_unit_cvt_factor;
+            }
+            for (int dd = 0; dd < atom->natoms; ++dd) {
+              fp << " " << setw(18) << std_f_all[dd];
+            }
+          }
+        }
+        if (rank == 0) {
+          fp << endl;
+        }
+      }
+    } else {
+      error->all(FLERR, "unknown computational branch");
+    }
+  } else {
+    if (numb_models == 1) {
+      try {
+        deep_pot.compute(dener, dforce, dvirial, dcoord, dtype, dbox);
+      } catch (deepmd_compat::deepmd_exception &e) {
+        error->one(FLERR, e.what());
+      }
+    } else {
+      error->all(FLERR, "Serial version does not support model devi");
+    }
+  }
+
+  // get force
+  if (!atom->sp_flag) {
+    for (int ii = 0; ii < nall; ++ii) {
+      for (int dd = 0; dd < 3; ++dd) {
+        f[ii][dd] += scale[1][1] * dforce[3 * ii + dd] * force_unit_cvt_factor;
+      }
+    }
+  } else {
+    // unit_factor = hbar / spin_norm;
+    const double hbar = 6.5821191e-04;
+    for (int ii = 0; ii < nall; ++ii) {
+      for (int dd = 0; dd < 3; ++dd) {
+        int new_idx = new_idx_map[ii];
+        f[ii][dd] +=
+            scale[1][1] * dforce[3 * new_idx + dd] * force_unit_cvt_factor;
+        if (dtype[ii] < numb_types_spin && ii < nlocal) {
+          fm[ii][dd] += scale[1][1] * dforce[3 * (new_idx + nlocal) + dd] /
+                        (hbar / spin_norm[dtype[ii]]) * force_unit_cvt_factor;
+        } else if (dtype[ii] < numb_types_spin) {
+          fm[ii][dd] += scale[1][1] * dforce[3 * (new_idx + nghost) + dd] /
+                        (hbar / spin_norm[dtype[ii]]) * force_unit_cvt_factor;
+        }
+      }
+    }
+  }
+
+  if (atom->sp_flag) {
+    std::map<int, int>().swap(new_idx_map);
+    std::map<int, int>().swap(old_idx_map);
+    // malloc_trim(0);
+  }
+
+  // accumulate energy and virial
+  if (eflag) {
+    eng_vdwl += scale[1][1] * dener * ener_unit_cvt_factor;
+  }
+  if (vflag) {
+    virial[0] += 1.0 * dvirial[0] * scale[1][1] * ener_unit_cvt_factor;
+    virial[1] += 1.0 * dvirial[4] * scale[1][1] * ener_unit_cvt_factor;
+    virial[2] += 1.0 * dvirial[8] * scale[1][1] * ener_unit_cvt_factor;
+    virial[3] += 1.0 * dvirial[3] * scale[1][1] * ener_unit_cvt_factor;
+    virial[4] += 1.0 * dvirial[6] * scale[1][1] * ener_unit_cvt_factor;
+    virial[5] += 1.0 * dvirial[7] * scale[1][1] * ener_unit_cvt_factor;
+  }
+}
+
+void PairDeepMD::allocate() {
+  allocated = 1;
+  int n = atom->ntypes;
+
+  memory->create(setflag, n + 1, n + 1, "pair:setflag");
+  memory->create(cutsq, n + 1, n + 1, "pair:cutsq");
+  memory->create(scale, n + 1, n + 1, "pair:scale");
+
+  for (int i = 1; i <= n; i++) {
+    for (int j = i; j <= n; j++) {
+      setflag[i][j] = 0;
+      scale[i][j] = 0;
+    }
+  }
+  for (int i = 1; i <= numb_types; ++i) {
+    if (i > n) {
+      continue;
+    }
+    for (int j = i; j <= numb_types; ++j) {
+      if (j > n) {
+        continue;
+      }
+      setflag[i][j] = 1;
+      scale[i][j] = 1.0;
+    }
+  }
+}
+
+static bool is_key(const string &input) {
+  vector<string> keys;
+  keys.push_back("out_freq");
+  keys.push_back("out_file");
+  keys.push_back("fparam");
+  keys.push_back("aparam");
+  keys.push_back("fparam_from_compute");
+  keys.push_back("aparam_from_compute");
+  keys.push_back("ttm");
+  keys.push_back("atomic");
+  keys.push_back("relative");
+  keys.push_back("relative_v");
+  keys.push_back("virtual_len");
+  keys.push_back("spin_norm");
+
+  for (int ii = 0; ii < keys.size(); ++ii) {
+    if (input == keys[ii]) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void PairDeepMD::settings(int narg, char **arg) {
+  if (narg <= 0) {
+    error->all(FLERR, "Illegal pair_style command");
+  }
+
+  vector<string> models;
+  int iarg = 0;
+  while (iarg < narg) {
+    if (is_key(arg[iarg])) {
+      break;
+    }
+    iarg++;
+  }
+  for (int ii = 0; ii < iarg; ++ii) {
+    models.push_back(arg[ii]);
+  }
+  numb_models = models.size();
+  if (numb_models == 1) {
+    try {
+      deep_pot.init(arg[0], get_node_rank(), get_file_content(arg[0]));
+    } catch (deepmd_compat::deepmd_exception &e) {
+      error->one(FLERR, e.what());
+    }
+    cutoff = deep_pot.cutoff() * dist_unit_cvt_factor;
+    numb_types = deep_pot.numb_types();
+    numb_types_spin = deep_pot.numb_types_spin();
+    dim_fparam = deep_pot.dim_fparam();
+    dim_aparam = deep_pot.dim_aparam();
+  } else {
+    try {
+      deep_pot.init(arg[0], get_node_rank(), get_file_content(arg[0]));
+      deep_pot_model_devi.init(models, get_node_rank(),
+                               get_file_content(models));
+    } catch (deepmd_compat::deepmd_exception &e) {
+      error->one(FLERR, e.what());
+    }
+    cutoff = deep_pot_model_devi.cutoff() * dist_unit_cvt_factor;
+    numb_types = deep_pot_model_devi.numb_types();
+    numb_types_spin = deep_pot_model_devi.numb_types_spin();
+    dim_fparam = deep_pot_model_devi.dim_fparam();
+    dim_aparam = deep_pot_model_devi.dim_aparam();
+    assert(cutoff == deep_pot.cutoff() * dist_unit_cvt_factor);
+    assert(numb_types == deep_pot.numb_types());
+    assert(numb_types_spin == deep_pot.numb_types_spin());
+    assert(dim_fparam == deep_pot.dim_fparam());
+    assert(dim_aparam == deep_pot.dim_aparam());
+  }
+
+  out_freq = 100;
+  out_file = "model_devi.out";
+  out_each = 0;
+  out_rel = 0;
+  eps = 0.;
+  fparam.clear();
+  aparam.clear();
+  while (iarg < narg) {
+    if (!is_key(arg[iarg])) {
+      error->all(FLERR,
+                 "Illegal pair_style command\nwrong number of parameters\n");
+    }
+    if (string(arg[iarg]) == string("out_freq")) {
+      if (iarg + 1 >= narg) {
+        error->all(FLERR, "Illegal out_freq, not provided");
+      }
+      out_freq = atoi(arg[iarg + 1]);
+      iarg += 2;
+    } else if (string(arg[iarg]) == string("out_file")) {
+      if (iarg + 1 >= narg) {
+        error->all(FLERR, "Illegal out_file, not provided");
+      }
+      out_file = string(arg[iarg + 1]);
+      iarg += 2;
+    } else if (string(arg[iarg]) == string("fparam")) {
+      for (int ii = 0; ii < dim_fparam; ++ii) {
+        if (iarg + 1 + ii >= narg || is_key(arg[iarg + 1 + ii])) {
+          char tmp[1024];
+          sprintf(tmp, "Illegal fparam, the dimension should be %d",
+                  dim_fparam);
+          error->all(FLERR, tmp);
+        }
+        fparam.push_back(atof(arg[iarg + 1 + ii]));
+      }
+      iarg += 1 + dim_fparam;
+    } else if (string(arg[iarg]) == string("aparam")) {
+      for (int ii = 0; ii < dim_aparam; ++ii) {
+        if (iarg + 1 + ii >= narg || is_key(arg[iarg + 1 + ii])) {
+          char tmp[1024];
+          sprintf(tmp, "Illegal aparam, the dimension should be %d",
+                  dim_aparam);
+          error->all(FLERR, tmp);
+        }
+        aparam.push_back(atof(arg[iarg + 1 + ii]));
+      }
+      iarg += 1 + dim_aparam;
+    } else if (string(arg[iarg]) == string("ttm")) {
+#ifdef USE_TTM
+      for (int ii = 0; ii < 1; ++ii) {
+        if (iarg + 1 + ii >= narg || is_key(arg[iarg + 1 + ii])) {
+          error->all(FLERR, "invalid ttm key: should be ttm ttm_fix_id(str)");
+        }
+      }
+      do_ttm = true;
+      ttm_fix_id = arg[iarg + 1];
+      iarg += 1 + 1;
+#else
+      error->all(FLERR,
+                 "The deepmd-kit was compiled without support for TTM, please "
+                 "rebuild it with LAMMPS version >=20210831");
+#endif
+    }
+
+    ///////////////////////////////////////////////
+    // pair_style     deepmd cp.pb fparam_from_compute TEMP
+    // compute        TEMP all temp
+    //////////////////////////////////////////////
+    else if (string(arg[iarg]) == string("fparam_from_compute")) {
+      for (int ii = 0; ii < 1; ++ii) {
+        if (iarg + 1 + ii >= narg || is_key(arg[iarg + 1 + ii])) {
+          error->all(FLERR,
+                     "invalid fparam_from_compute key: should be "
+                     "fparam_from_compute compute_fparam_id(str)");
+        }
+      }
+      do_compute_fparam = true;
+      compute_fparam_id = arg[iarg + 1];
+      iarg += 1 + 1;
+    } else if (string(arg[iarg]) == string("aparam_from_compute")) {
+      for (int ii = 0; ii < 1; ++ii) {
+        if (iarg + 1 + ii >= narg || is_key(arg[iarg + 1 + ii])) {
+          error->all(FLERR,
+                     "invalid aparam_from_compute key: should be "
+                     "aparam_from_compute compute_aparam_id(str)");
+        }
+      }
+      do_compute_aparam = true;
+      compute_aparam_id = arg[iarg + 1];
+      iarg += 1 + 1;
+    } else if (string(arg[iarg]) == string("atomic")) {
+      out_each = 1;
+      iarg += 1;
+    } else if (string(arg[iarg]) == string("relative")) {
+      out_rel = 1;
+      eps = atof(arg[iarg + 1]) / ener_unit_cvt_factor;
+      iarg += 2;
+    } else if (string(arg[iarg]) == string("relative_v")) {
+      out_rel_v = 1;
+      eps_v = atof(arg[iarg + 1]) / ener_unit_cvt_factor;
+      iarg += 2;
+    } else if (string(arg[iarg]) == string("virtual_len")) {
+      virtual_len.resize(numb_types_spin);
+      for (int ii = 0; ii < numb_types_spin; ++ii) {
+        virtual_len[ii] = atof(arg[iarg + ii + 1]);
+      }
+      iarg += numb_types_spin + 1;
+    } else if (string(arg[iarg]) == string("spin_norm")) {
+      spin_norm.resize(numb_types_spin);
+      for (int ii = 0; ii < numb_types_spin; ++ii) {
+        spin_norm[ii] = atof(arg[iarg + ii + 1]);
+      }
+      iarg += numb_types_spin + 1;
+    }
+  }
+
+  if (out_freq < 0) {
+    error->all(FLERR, "Illegal out_freq, should be >= 0");
+  }
+  if ((int)do_ttm + (int)do_compute_aparam + (int)(aparam.size() > 0) > 1) {
+    error->all(FLERR,
+               "aparam, aparam_from_compute, and ttm should NOT be set "
+               "simultaneously");
+  }
+  if (do_compute_fparam && fparam.size() > 0) {
+    error->all(
+        FLERR,
+        "fparam and fparam_from_compute should NOT be set simultaneously");
+  }
+
+  if (comm->me == 0) {
+    if (numb_models > 1 && out_freq > 0) {
+      if (!is_restart) {
+        fp.open(out_file);
+        fp << scientific;
+        fp << "#" << setw(12 - 1) << "step" << setw(18 + 1) << "max_devi_v"
+           << setw(18 + 1) << "min_devi_v" << setw(18 + 1) << "avg_devi_v"
+           << setw(18 + 1) << "max_devi_f" << setw(18 + 1) << "min_devi_f"
+           << setw(18 + 1) << "avg_devi_f";
+        if (out_each) {
+          // at this time, we don't know how many atoms
+          fp << setw(18 + 1) << "atm_devi_f(N)";
+        }
+        fp << endl;
+      } else {
+        fp.open(out_file, std::ofstream::out | std::ofstream::app);
+        fp << scientific;
+      }
+    }
+    string pre = "  ";
+    cout << pre << ">>> Info of model(s):" << endl
+         << pre << "using " << setw(3) << numb_models << " model(s): ";
+    if (narg == 1) {
+      cout << arg[0] << " ";
+    } else {
+      for (int ii = 0; ii < models.size(); ++ii) {
+        cout << models[ii] << " ";
+      }
+    }
+    cout << endl
+         << pre << "rcut in model:      " << cutoff << endl
+         << pre << "ntypes in model:    " << numb_types << endl;
+    if (fparam.size() > 0) {
+      cout << pre << "using fparam(s):    ";
+      for (int ii = 0; ii < dim_fparam; ++ii) {
+        cout << fparam[ii] << "  ";
+      }
+      cout << endl;
+    }
+    if (do_compute_fparam) {
+      cout << pre << "using compute id (fparam):      ";
+      cout << compute_fparam_id << "  " << endl;
+    }
+    if (do_compute_aparam) {
+      cout << pre << "using compute id (aparam):      ";
+      cout << compute_aparam_id << "  " << endl;
+    }
+    if (aparam.size() > 0) {
+      cout << pre << "using aparam(s):    ";
+      for (int ii = 0; ii < aparam.size(); ++ii) {
+        cout << aparam[ii] << "  ";
+      }
+      cout << endl;
+    }
+    if (do_ttm) {
+      cout << pre << "using ttm fix:      ";
+      cout << ttm_fix_id << "  ";
+      if (dim_fparam > 0) {
+        cout << "(fparam)" << endl;
+      } else if (dim_aparam > 0) {
+        cout << "(aparam)" << endl;
+      }
+    }
+  }
+
+  comm_reverse = numb_models * 3;
+  all_force.resize(numb_models);
+}
+
+void PairDeepMD::read_restart(FILE *) { is_restart = true; }
+
+void PairDeepMD::write_restart(FILE *) {
+  // pass
+}
+
+/* ----------------------------------------------------------------------
+   set coeffs for one or more type pairs
+------------------------------------------------------------------------- */
+
+void PairDeepMD::coeff(int narg, char **arg) {
+  if (!allocated) {
+    allocate();
+  }
+
+  int n = atom->ntypes;
+  int ilo, ihi, jlo, jhi;
+  ilo = 0;
+  jlo = 0;
+  ihi = n;
+  jhi = n;
+  if (narg >= 2) {
+    utils::bounds(FLERR, arg[0], 1, atom->ntypes, ilo, ihi, error);
+    utils::bounds(FLERR, arg[1], 1, atom->ntypes, jlo, jhi, error);
+    if (ilo != 1 || jlo != 1 || ihi != n || jhi != n) {
+      error->all(FLERR,
+                 "deepmd requires that the scale should be set to all atom "
+                 "types, i.e. pair_coeff * *.");
+    }
+  }
+  if (narg <= 2) {
+    type_idx_map.resize(n);
+    for (int ii = 0; ii < n; ++ii) {
+      type_idx_map[ii] = ii;
+    }
+  } else {
+    int iarg = 2;
+
+    // type_map is a list of strings with undetermined length
+    // note: although we have numb_types from the model, we do not require
+    // the number of types in the system matches that in the model
+    std::vector<std::string> type_map;
+    std::string type_map_str;
+    deep_pot.get_type_map(type_map_str);
+    // convert the string to a vector of strings
+    std::istringstream iss(type_map_str);
+    std::string type_name;
+    while (iss >> type_name) {
+      type_map.push_back(type_name);
+    }
+
+    type_idx_map.clear();
+    type_names.clear();
+    while (iarg < narg) {
+      std::string type_name = arg[iarg];
+      type_names.push_back(type_name);
+      bool found_element = false;
+      for (int ii = 0; ii < type_map.size(); ++ii) {
+        if (type_map[ii] == type_name) {
+          type_idx_map.push_back(ii);
+          found_element = true;
+          break;
+        }
+      }
+      if (!found_element && "NULL" == type_name) {
+        type_idx_map.push_back(type_map.size());  // ghost type
+        found_element = true;
+      }
+      if (!found_element) {
+        error->all(FLERR, "pair_coeff: element " + type_name +
+                              " not found in the model");
+      }
+      iarg += 1;
+    }
+    numb_types = type_idx_map.size();
+    if (numb_types < n) {
+      type_idx_map.resize(n);
+      for (int ii = numb_types; ii < n; ++ii) {
+        type_idx_map[ii] = -1;
+      }
+    }
+  }
+  for (int i = ilo; i <= ihi; i++) {
+    for (int j = MAX(jlo, i); j <= jhi; j++) {
+      setflag[i][j] = 1;
+      scale[i][j] = 1.0;
+      if (i > numb_types || j > numb_types) {
+        char warning_msg[1024];
+        sprintf(warning_msg,
+                "Interaction between types %d and %d is set with deepmd, but "
+                "will be ignored.\n Deepmd model has only %d types, it only "
+                "computes the mulitbody interaction of types: 1-%d.",
+                i, j, numb_types, numb_types);
+        error->warning(FLERR, warning_msg);
+      }
+    }
+  }
+}
+
+void PairDeepMD::init_style() {
+#if LAMMPS_VERSION_NUMBER >= 20220324
+  neighbor->add_request(this, NeighConst::REQ_FULL);
+#else
+  int irequest = neighbor->request(this, instance_me);
+  neighbor->requests[irequest]->half = 0;
+  neighbor->requests[irequest]->full = 1;
+  // neighbor->requests[irequest]->newton = 2;
+#endif
+  if (out_each == 1) {
+    int ntotal = atom->natoms;
+    int nprocs = comm->nprocs;
+    if (ntotal > stdf_comm_buff_size) {
+      stdf_comm_buff_size = ntotal;
+    }
+    memory->create(counts, nprocs, "deepmd:counts");
+    memory->create(displacements, nprocs, "deepmd:displacements");
+    memory->create(stdfsend, ntotal, "deepmd:stdfsendall");
+    memory->create(stdfrecv, ntotal, "deepmd:stdfrecvall");
+    memory->create(tagsend, ntotal, "deepmd:tagsendall");
+    memory->create(tagrecv, ntotal, "deepmd:tagrecvall");
+  }
+}
+
+double PairDeepMD::init_one(int i, int j) {
+  if (i > numb_types || j > numb_types) {
+    char warning_msg[1024];
+    sprintf(warning_msg,
+            "Interaction between types %d and %d is set with deepmd, but will "
+            "be ignored.\n Deepmd model has only %d types, it only computes "
+            "the mulitbody interaction of types: 1-%d.",
+            i, j, numb_types, numb_types);
+    error->warning(FLERR, warning_msg);
+  }
+
+  if (setflag[i][j] == 0) {
+    scale[i][j] = 1.0;
+  }
+  scale[j][i] = scale[i][j];
+
+  return cutoff;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int PairDeepMD::pack_reverse_comm(int n, int first, double *buf) {
+  int i, m, last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    for (int dd = 0; dd < numb_models; ++dd) {
+      buf[m++] = all_force[dd][3 * i + 0];
+      buf[m++] = all_force[dd][3 * i + 1];
+      buf[m++] = all_force[dd][3 * i + 2];
+    }
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairDeepMD::unpack_reverse_comm(int n, int *list, double *buf) {
+  int i, j, m;
+
+  m = 0;
+  for (i = 0; i < n; i++) {
+    j = list[i];
+    for (int dd = 0; dd < numb_models; ++dd) {
+      all_force[dd][3 * j + 0] += buf[m++];
+      all_force[dd][3 * j + 1] += buf[m++];
+      all_force[dd][3 * j + 2] += buf[m++];
+    }
+  }
+}
+
+void *PairDeepMD::extract(const char *str, int &dim) {
+  if (strcmp(str, "cut_coul") == 0) {
+    dim = 0;
+    return (void *)&cutoff;
+  }
+  if (strcmp(str, "scale") == 0) {
+    dim = 2;
+    return (void *)scale;
+  }
+  return NULL;
+}
+
+void PairDeepMD::extend(int &extend_inum,
+                        std::vector<int> &extend_ilist,
+                        std::vector<int> &extend_numneigh,
+                        std::vector<vector<int>> &extend_neigh,
+                        std::vector<int *> &extend_firstneigh,
+                        std::vector<double> &extend_dcoord,
+                        std::vector<int> &extend_atype,
+                        int &extend_nghost,
+                        std::map<int, int> &new_idx_map,
+                        std::map<int, int> &old_idx_map,
+                        const deepmd_compat::InputNlist &lmp_list,
+                        const std::vector<double> &dcoord,
+                        const std::vector<int> &atype,
+                        const int nghost,
+                        const std::vector<double> &spin,
+                        const int numb_types,
+                        const int numb_types_spin,
+                        const std::vector<double> &virtual_len) {
+  extend_ilist.clear();
+  extend_numneigh.clear();
+  extend_neigh.clear();
+  extend_firstneigh.clear();
+  extend_dcoord.clear();
+  extend_atype.clear();
+
+  int nall = dcoord.size() / 3;
+  int nloc = nall - nghost;
+  assert(nloc == lmp_list.inum);
+
+  // record numb_types_real and nloc_virt
+  int numb_types_real = numb_types - numb_types_spin;
+  std::map<int, int> loc_type_count;
+  std::map<int, int>::iterator iter = loc_type_count.begin();
+  for (int i = 0; i < nloc; i++) {
+    iter = loc_type_count.find(atype[i]);
+    if (iter != loc_type_count.end()) {
+      iter->second += 1;
+    } else {
+      loc_type_count.insert(pair<int, int>(atype[i], 1));
+    }
+  }
+  assert(numb_types_real - 1 == loc_type_count.rbegin()->first);
+  int nloc_virt = 0;
+  for (int i = 0; i < numb_types_spin; i++) {
+    nloc_virt += loc_type_count[i];
+  }
+
+  // record nghost_virt
+  std::map<int, int> ghost_type_count;
+  for (int i = nloc; i < nall; i++) {
+    iter = ghost_type_count.find(atype[i]);
+    if (iter != ghost_type_count.end()) {
+      iter->second += 1;
+    } else {
+      ghost_type_count.insert(pair<int, int>(atype[i], 1));
+    }
+  }
+  int nghost_virt = 0;
+  for (int i = 0; i < numb_types_spin; i++) {
+    nghost_virt += ghost_type_count[i];
+  }
+
+  // for extended system, search new index by old index, and vice versa
+  extend_nghost = nghost + nghost_virt;
+  int extend_nloc = nloc + nloc_virt;
+  int extend_nall = extend_nloc + extend_nghost;
+  std::map<int, int> cum_loc_type_count;
+  std::map<int, int> cum_ghost_type_count;
+  cum_sum(cum_loc_type_count, loc_type_count);
+  cum_sum(cum_ghost_type_count, ghost_type_count);
+  std::vector<int> loc_type_reset(numb_types_real, 0);
+  std::vector<int> ghost_type_reset(numb_types_real, 0);
+
+  new_idx_map.clear();
+  old_idx_map.clear();
+  for (int ii = 0; ii < nloc; ii++) {
+    int new_idx = cum_loc_type_count[atype[ii]] + loc_type_reset[atype[ii]];
+    new_idx_map[ii] = new_idx;
+    old_idx_map[new_idx] = ii;
+    loc_type_reset[atype[ii]]++;
+  }
+  for (int ii = nloc; ii < nall; ii++) {
+    int new_idx = cum_ghost_type_count[atype[ii]] +
+                  ghost_type_reset[atype[ii]] + extend_nloc;
+    new_idx_map[ii] = new_idx;
+    old_idx_map[new_idx] = ii;
+    ghost_type_reset[atype[ii]]++;
+  }
+
+  // extend lmp_list
+  extend_inum = extend_nloc;
+
+  extend_ilist.resize(extend_nloc);
+  for (int ii = 0; ii < extend_nloc; ii++) {
+    extend_ilist[ii] = ii;
+  }
+
+  extend_neigh.resize(extend_nloc);
+  for (int ii = 0; ii < nloc; ii++) {
+    int jnum = lmp_list.numneigh[old_idx_map[ii]];
+    const int *jlist = lmp_list.firstneigh[old_idx_map[ii]];
+    if (atype[old_idx_map[ii]] < numb_types_spin) {
+      extend_neigh[ii].push_back(ii + nloc);
+    }
+    for (int jj = 0; jj < jnum; jj++) {
+      int new_idx = new_idx_map[jlist[jj]];
+      extend_neigh[ii].push_back(new_idx);
+      if (atype[jlist[jj]] < numb_types_spin && jlist[jj] < nloc) {
+        extend_neigh[ii].push_back(new_idx + nloc);
+      } else if (atype[jlist[jj]] < numb_types_spin && jlist[jj] < nall) {
+        extend_neigh[ii].push_back(new_idx + nghost);
+      }
+    }
+  }
+  for (int ii = nloc; ii < extend_nloc; ii++) {
+    extend_neigh[ii].assign(extend_neigh[ii - nloc].begin(),
+                            extend_neigh[ii - nloc].end());
+    std::vector<int>::iterator it =
+        find(extend_neigh[ii].begin(), extend_neigh[ii].end(), ii);
+    *it = ii - nloc;
+  }
+
+  extend_firstneigh.resize(extend_nloc);
+  extend_numneigh.resize(extend_nloc);
+  for (int ii = 0; ii < extend_nloc; ii++) {
+    extend_firstneigh[ii] = &extend_neigh[ii][0];
+    extend_numneigh[ii] = extend_neigh[ii].size();
+  }
+
+  // extend coord
+  extend_dcoord.resize(static_cast<size_t>(extend_nall) * 3);
+  for (int ii = 0; ii < nloc; ii++) {
+    for (int jj = 0; jj < 3; jj++) {
+      extend_dcoord[new_idx_map[ii] * 3 + jj] = dcoord[ii * 3 + jj];
+      if (atype[ii] < numb_types_spin) {
+        double temp_dcoord =
+            dcoord[ii * 3 + jj] + spin[ii * 3 + jj] * virtual_len[atype[ii]];
+        extend_dcoord[(new_idx_map[ii] + nloc) * 3 + jj] = temp_dcoord;
+      }
+    }
+  }
+  for (int ii = nloc; ii < nall; ii++) {
+    for (int jj = 0; jj < 3; jj++) {
+      extend_dcoord[new_idx_map[ii] * 3 + jj] = dcoord[ii * 3 + jj];
+      if (atype[ii] < numb_types_spin) {
+        double temp_dcoord =
+            dcoord[ii * 3 + jj] + spin[ii * 3 + jj] * virtual_len[atype[ii]];
+        extend_dcoord[(new_idx_map[ii] + nghost) * 3 + jj] = temp_dcoord;
+      }
+    }
+  }
+
+  // extend atype
+  extend_atype.resize(extend_nall);
+  for (int ii = 0; ii < nall; ii++) {
+    extend_atype[new_idx_map[ii]] = atype[ii];
+    if (atype[ii] < numb_types_spin) {
+      if (ii < nloc) {
+        extend_atype[new_idx_map[ii] + nloc] = atype[ii] + numb_types_real;
+      } else {
+        extend_atype[new_idx_map[ii] + nghost] = atype[ii] + numb_types_real;
+      }
+    }
+  }
+}
diff --git a/src/USER-DEEPMD/pair_deepmd.h b/src/USER-DEEPMD/pair_deepmd.h
new file mode 100644
index 0000000000..cd72dc7b2a
--- /dev/null
+++ b/src/USER-DEEPMD/pair_deepmd.h
@@ -0,0 +1,145 @@
+// SPDX-License-Identifier: LGPL-3.0-or-later
+#ifndef LAMMPS_VERSION_NUMBER
+#error Please define LAMMPS_VERSION_NUMBER to yyyymmdd
+#endif
+
+#ifdef PAIR_CLASS
+
+PairStyle(deepmd, PairDeepMD)
+
+#else
+
+#ifndef LMP_PAIR_NNP_H
+#define LMP_PAIR_NNP_H
+
+#include "pair.h"
+#ifdef DP_USE_CXX_API
+#ifdef LMPPLUGIN
+#include "DeepPot.h"
+#else
+#include "deepmd/DeepPot.h"
+#endif
+namespace deepmd_compat = deepmd;
+#else
+#ifdef LMPPLUGIN
+#include "deepmd.hpp"
+#else
+#include "deepmd/deepmd.hpp"
+#endif
+namespace deepmd_compat = deepmd::hpp;
+#endif
+#include <fstream>
+#include <iostream>
+#include <map>
+
+#define FLOAT_PREC double
+
+namespace LAMMPS_NS {
+
+class PairDeepMD : public Pair {
+ public:
+  PairDeepMD(class LAMMPS *);
+  ~PairDeepMD() override;
+  void compute(int, int) override;
+  void *extract(const char *, int &) override;
+  void settings(int, char **) override;
+  void coeff(int, char **) override;
+  void init_style() override;
+  void write_restart(FILE *) override;
+  void read_restart(FILE *) override;
+  double init_one(int i, int j) override;
+  int pack_reverse_comm(int, int, double *) override;
+  void unpack_reverse_comm(int, int *, double *) override;
+  void print_summary(const std::string pre) const;
+  int get_node_rank();
+  void extend(int &extend_inum,
+              std::vector<int> &extend_ilist,
+              std::vector<int> &extend_numneigh,
+              std::vector<std::vector<int> > &extend_neigh,
+              std::vector<int *> &extend_firstneigh,
+              std::vector<double> &extend_coord,
+              std::vector<int> &extend_atype,
+              int &extend_nghost,
+              std::map<int, int> &new_idx_map,
+              std::map<int, int> &old_idx_map,
+              const deepmd_compat::InputNlist &lmp_list,
+              const std::vector<double> &coord,
+              const std::vector<int> &atype,
+              const int nghost,
+              const std::vector<double> &spin,
+              const int numb_types,
+              const int numb_types_spin,
+              const std::vector<double> &virtual_len);
+  void cum_sum(std::map<int, int> &, std::map<int, int> &);
+
+  std::string get_file_content(const std::string &model);
+  std::vector<std::string> get_file_content(
+      const std::vector<std::string> &models);
+  std::vector<std::string> type_names;
+  double ener_unit_cvt_factor, dist_unit_cvt_factor, force_unit_cvt_factor;
+
+ protected:
+  virtual void allocate();
+  double **scale;
+
+ private:
+  deepmd_compat::DeepPot deep_pot;
+  deepmd_compat::DeepPotModelDevi deep_pot_model_devi;
+  unsigned numb_models;
+  double cutoff;
+  int numb_types;
+  int numb_types_spin;
+  std::vector<std::vector<double> > all_force;
+  std::ofstream fp;
+  int out_freq;
+  std::string out_file;
+  int dim_fparam;
+  int dim_aparam;
+  int out_each;
+  int out_rel;
+  int out_rel_v;
+  int stdf_comm_buff_size;
+  bool single_model;
+  bool multi_models_mod_devi;
+  bool multi_models_no_mod_devi;
+  bool is_restart;
+  std::vector<double> virtual_len;
+  std::vector<double> spin_norm;
+  int extend_inum;
+  std::vector<int> extend_ilist;
+  std::vector<int> extend_numneigh;
+  std::vector<std::vector<int> > extend_neigh;
+  std::vector<int *> extend_firstneigh;
+  std::vector<double> extend_dcoord;
+  std::vector<int> extend_dtype;
+  int extend_nghost;
+  // for spin systems, search new index of atoms by their old index
+  std::map<int, int> new_idx_map;
+  std::map<int, int> old_idx_map;
+  std::vector<double> fparam;
+  std::vector<double> aparam;
+  double eps;
+  double eps_v;
+
+  void make_fparam_from_compute(std::vector<double> &fparam);
+  bool do_compute_fparam;
+  std::string compute_fparam_id;
+  void make_aparam_from_compute(std::vector<double> &aparam);
+  bool do_compute_aparam;
+  std::string compute_aparam_id;
+
+  void make_ttm_fparam(std::vector<double> &fparam);
+
+  void make_ttm_aparam(std::vector<double> &dparam);
+  bool do_ttm;
+  std::string ttm_fix_id;
+  int *counts, *displacements;
+  tagint *tagsend, *tagrecv;
+  double *stdfsend, *stdfrecv;
+  std::vector<int> type_idx_map;
+};
+
+}  // namespace LAMMPS_NS
+
+#endif
+#endif
diff --git a/src/USER-DEEPMD/pppm_dplr.cpp b/src/USER-DEEPMD/pppm_dplr.cpp
new file mode 100644
index 0000000000..613a9f1c93
--- /dev/null
+++ b/src/USER-DEEPMD/pppm_dplr.cpp
@@ -0,0 +1,430 @@
+// SPDX-License-Identifier: LGPL-3.0-or-later
+#include "pppm_dplr.h"
+
+#include <math.h>
+
+#include "atom.h"
+#include "domain.h"
+#include "error.h"
+#include "force.h"
+#if LAMMPS_VERSION_NUMBER >= 20221222
+#include "grid3d.h"
+#else
+#include "gridcomm.h"
+#endif
+#include "math_const.h"
+#include "memory.h"
+#include "pppm.h"
+
+using namespace LAMMPS_NS;
+using namespace MathConst;
+
+enum { REVERSE_RHO };
+enum { FORWARD_IK, FORWARD_AD, FORWARD_IK_PERATOM, FORWARD_AD_PERATOM };
+
+#define OFFSET 16384
+
+#ifdef FFT_SINGLE
+#define ZEROF 0.0f
+#define ONEF 1.0f
+#else
+#define ZEROF 0.0
+#define ONEF 1.0
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+#if LAMMPS_VERSION_NUMBER < 20181109
+// See lammps/lammps#1165
+PPPMDPLR::PPPMDPLR(LAMMPS *lmp, int narg, char **arg)
+    : PPPM(lmp, narg, arg)
+#else
+PPPMDPLR::PPPMDPLR(LAMMPS *lmp)
+    : PPPM(lmp)
+#endif
+{
+  triclinic_support = 1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PPPMDPLR::init() {
+  // DPLR PPPM requires newton on, b/c it computes forces on ghost atoms
+
+  if (force->newton == 0) {
+    error->all(FLERR, "Kspace style pppm/dplr requires newton on");
+  }
+
+  PPPM::init();
+
+  int nlocal = atom->nlocal;
+  // cout << " ninit pppm/dplr ---------------------- " << nlocal << endl;
+  fele.resize(static_cast<size_t>(nlocal) * 3);
+  fill(fele.begin(), fele.end(), 0.0);
+}
+
+/* ----------------------------------------------------------------------
+   compute the PPPM long-range force, energy, virial
+------------------------------------------------------------------------- */
+
+void PPPMDPLR::compute(int eflag, int vflag) {
+  int i, j;
+
+  // set energy/virial flags
+  // invoke allocate_peratom() if needed for first time
+
+  ev_init(eflag, vflag);
+
+  if (evflag_atom && !peratom_allocate_flag) {
+    allocate_peratom();
+  }
+
+  // if atom count has changed, update qsum and qsqsum
+
+  if (atom->natoms != natoms_original) {
+    qsum_qsq();
+    natoms_original = atom->natoms;
+  }
+
+  // return if there are no charges
+
+  if (qsqsum == 0.0) {
+    return;
+  }
+
+  // convert atoms from box to lamda coords
+
+  if (triclinic == 0) {
+    boxlo = domain->boxlo;
+  } else {
+    boxlo = domain->boxlo_lamda;
+    domain->x2lamda(atom->nlocal);
+  }
+
+  // extend size of per-atom arrays if necessary
+
+  if (atom->nmax > nmax) {
+    memory->destroy(part2grid);
+    nmax = atom->nmax;
+    memory->create(part2grid, nmax, 3, "pppm:part2grid");
+  }
+
+  // find grid points for all my particles
+  // map my particle charge onto my local 3d density grid
+
+  particle_map();
+  make_rho();
+
+  // all procs communicate density values from their ghost cells
+  //   to fully sum contribution in their 3d bricks
+  // remap from 3d decomposition to FFT decomposition
+
+#if LAMMPS_VERSION_NUMBER >= 20221222
+  gc->reverse_comm(Grid3d::KSPACE, this, REVERSE_RHO, 1, sizeof(FFT_SCALAR),
+                   gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#elif LAMMPS_VERSION_NUMBER >= 20210831 && LAMMPS_VERSION_NUMBER < 20221222
+  gc->reverse_comm(GridComm::KSPACE, this, 1, sizeof(FFT_SCALAR), REVERSE_RHO,
+                   gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#else
+  gc->reverse_comm_kspace(this, 1, sizeof(FFT_SCALAR), REVERSE_RHO, gc_buf1,
+                          gc_buf2, MPI_FFT_SCALAR);
+#endif
+  brick2fft();
+
+  // compute potential gradient on my FFT grid and
+  //   portion of e_long on this proc's FFT grid
+  // return gradients (electric fields) in 3d brick decomposition
+  // also performs per-atom calculations via poisson_peratom()
+
+  poisson();
+
+  // all procs communicate E-field values
+  // to fill ghost cells surrounding their 3d bricks
+
+  if (differentiation_flag == 1)
+#if LAMMPS_VERSION_NUMBER >= 20221222
+    gc->reverse_comm(Grid3d::KSPACE, this, REVERSE_RHO, 1, sizeof(FFT_SCALAR),
+                     gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#elif LAMMPS_VERSION_NUMBER >= 20210831 && LAMMPS_VERSION_NUMBER < 20221222
+    gc->forward_comm(GridComm::KSPACE, this, 1, sizeof(FFT_SCALAR), FORWARD_AD,
+                     gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#else
+    gc->forward_comm_kspace(this, 1, sizeof(FFT_SCALAR), FORWARD_AD, gc_buf1,
+                            gc_buf2, MPI_FFT_SCALAR);
+#endif
+  else
+#if LAMMPS_VERSION_NUMBER >= 20221222
+    gc->forward_comm(Grid3d::KSPACE, this, FORWARD_IK, 3, sizeof(FFT_SCALAR),
+                     gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#elif LAMMPS_VERSION_NUMBER >= 20210831 && LAMMPS_VERSION_NUMBER < 20221222
+    gc->forward_comm(GridComm::KSPACE, this, 3, sizeof(FFT_SCALAR), FORWARD_IK,
+                     gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#else
+    gc->forward_comm_kspace(this, 3, sizeof(FFT_SCALAR), FORWARD_IK, gc_buf1,
+                            gc_buf2, MPI_FFT_SCALAR);
+#endif
+
+  // extra per-atom energy/virial communication
+
+  if (evflag_atom) {
+    if (differentiation_flag == 1 && vflag_atom)
+#if LAMMPS_VERSION_NUMBER >= 20221222
+      gc->forward_comm(Grid3d::KSPACE, this, FORWARD_AD_PERATOM, 6,
+                       sizeof(FFT_SCALAR), gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#elif LAMMPS_VERSION_NUMBER >= 20210831 && LAMMPS_VERSION_NUMBER < 20221222
+      gc->forward_comm(GridComm::KSPACE, this, 6, sizeof(FFT_SCALAR),
+                       FORWARD_AD_PERATOM, gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#else
+      gc->forward_comm_kspace(this, 6, sizeof(FFT_SCALAR), FORWARD_AD_PERATOM,
+                              gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#endif
+    else if (differentiation_flag == 0)
+#if LAMMPS_VERSION_NUMBER >= 20221222
+      gc->forward_comm(Grid3d::KSPACE, this, FORWARD_IK_PERATOM, 7,
+                       sizeof(FFT_SCALAR), gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#elif LAMMPS_VERSION_NUMBER >= 20210831 && LAMMPS_VERSION_NUMBER < 20221222
+      gc->forward_comm(GridComm::KSPACE, this, 7, sizeof(FFT_SCALAR),
+                       FORWARD_IK_PERATOM, gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#else
+      gc->forward_comm_kspace(this, 7, sizeof(FFT_SCALAR), FORWARD_IK_PERATOM,
+                              gc_buf1, gc_buf2, MPI_FFT_SCALAR);
+#endif
+  }
+
+  // calculate the force on my particles
+
+  fieldforce();
+
+  // extra per-atom energy/virial communication
+
+  if (evflag_atom) {
+    fieldforce_peratom();
+  }
+
+  // sum global energy across procs and add in volume-dependent term
+
+  const double qscale = qqrd2e * scale;
+
+  if (eflag_global) {
+    double energy_all;
+    MPI_Allreduce(&energy, &energy_all, 1, MPI_DOUBLE, MPI_SUM, world);
+    energy = energy_all;
+
+    energy *= 0.5 * volume;
+    // do not add self-term, for neutral systems qsum == 0
+    // energy -= g_ewald*qsqsum/MY_PIS +
+    //   MY_PI2*qsum*qsum / (g_ewald*g_ewald*volume);
+    energy *= qscale;
+  }
+
+  // sum global virial across procs
+
+  if (vflag_global) {
+    double virial_all[6];
+    MPI_Allreduce(virial, virial_all, 6, MPI_DOUBLE, MPI_SUM, world);
+    for (i = 0; i < 6; i++) {
+      virial[i] = 0.5 * qscale * volume * virial_all[i];
+    }
+  }
+
+  // per-atom energy/virial
+  // energy includes self-energy correction
+  // ntotal accounts for TIP4P tallying eatom/vatom for ghost atoms
+
+  if (evflag_atom) {
+    double *q = atom->q;
+    int nlocal = atom->nlocal;
+    int ntotal = nlocal;
+    if (tip4pflag) {
+      ntotal += atom->nghost;
+    }
+
+    if (eflag_atom) {
+      for (i = 0; i < nlocal; i++) {
+        eatom[i] *= 0.5;
+        eatom[i] -= g_ewald * q[i] * q[i] / MY_PIS +
+                    MY_PI2 * q[i] * qsum / (g_ewald * g_ewald * volume);
+        eatom[i] *= qscale;
+      }
+      for (i = nlocal; i < ntotal; i++) {
+        eatom[i] *= 0.5 * qscale;
+      }
+    }
+
+    if (vflag_atom) {
+      for (i = 0; i < ntotal; i++) {
+        for (j = 0; j < 6; j++) {
+          vatom[i][j] *= 0.5 * qscale;
+        }
+      }
+    }
+  }
+
+  // 2d slab correction
+
+  if (slabflag == 1) {
+    slabcorr();
+  }
+
+  // convert atoms back from lamda to box coords
+
+  if (triclinic) {
+    domain->lamda2x(atom->nlocal);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   interpolate from grid to get electric field & force on my particles for ik
+------------------------------------------------------------------------- */
+
+void PPPMDPLR::fieldforce_ik() {
+  int i, l, m, n, nx, ny, nz, mx, my, mz;
+  FFT_SCALAR dx, dy, dz, x0, y0, z0;
+  FFT_SCALAR ekx, eky, ekz;
+
+  // loop over my charges, interpolate electric field from nearby grid points
+  // (nx,ny,nz) = global coords of grid pt to "lower left" of charge
+  // (dx,dy,dz) = distance to "lower left" grid pt
+  // (mx,my,mz) = global coords of moving stencil pt
+  // ek = 3 components of E-field on particle
+
+  double *q = atom->q;
+  double **x = atom->x;
+  // double **f = atom->f;
+
+  int nlocal = atom->nlocal;
+  int nghost = atom->nghost;
+  int nall = nlocal + nghost;
+
+  fele.resize(static_cast<size_t>(nlocal) * 3);
+  fill(fele.begin(), fele.end(), 0.0);
+
+  for (i = 0; i < nlocal; i++) {
+    nx = part2grid[i][0];
+    ny = part2grid[i][1];
+    nz = part2grid[i][2];
+    dx = nx + shiftone - (x[i][0] - boxlo[0]) * delxinv;
+    dy = ny + shiftone - (x[i][1] - boxlo[1]) * delyinv;
+    dz = nz + shiftone - (x[i][2] - boxlo[2]) * delzinv;
+
+    compute_rho1d(dx, dy, dz);
+
+    ekx = eky = ekz = ZEROF;
+    for (n = nlower; n <= nupper; n++) {
+      mz = n + nz;
+      z0 = rho1d[2][n];
+      for (m = nlower; m <= nupper; m++) {
+        my = m + ny;
+        y0 = z0 * rho1d[1][m];
+        for (l = nlower; l <= nupper; l++) {
+          mx = l + nx;
+          x0 = y0 * rho1d[0][l];
+          ekx -= x0 * vdx_brick[mz][my][mx];
+          eky -= x0 * vdy_brick[mz][my][mx];
+          ekz -= x0 * vdz_brick[mz][my][mx];
+        }
+      }
+    }
+
+    // convert E-field to force
+
+    const double qfactor = qqrd2e * scale * q[i];
+    fele[i * 3 + 0] += qfactor * ekx;
+    fele[i * 3 + 1] += qfactor * eky;
+    if (slabflag != 2) {
+      fele[i * 3 + 2] += qfactor * ekz;
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   interpolate from grid to get electric field & force on my particles for ad
+------------------------------------------------------------------------- */
+
+void PPPMDPLR::fieldforce_ad() {
+  int i, l, m, n, nx, ny, nz, mx, my, mz;
+  FFT_SCALAR dx, dy, dz;
+  FFT_SCALAR ekx, eky, ekz;
+  double s1, s2, s3;
+  double sf = 0.0;
+  double *prd;
+
+  prd = domain->prd;
+  double xprd = prd[0];
+  double yprd = prd[1];
+  double zprd = prd[2];
+
+  double hx_inv = nx_pppm / xprd;
+  double hy_inv = ny_pppm / yprd;
+  double hz_inv = nz_pppm / zprd;
+
+  // loop over my charges, interpolate electric field from nearby grid points
+  // (nx,ny,nz) = global coords of grid pt to "lower left" of charge
+  // (dx,dy,dz) = distance to "lower left" grid pt
+  // (mx,my,mz) = global coords of moving stencil pt
+  // ek = 3 components of E-field on particle
+
+  double *q = atom->q;
+  double **x = atom->x;
+  // double **f = atom->f;
+
+  int nlocal = atom->nlocal;
+  int nghost = atom->nghost;
+  int nall = nlocal + nghost;
+
+  fele.resize(static_cast<size_t>(nlocal) * 3);
+  fill(fele.begin(), fele.end(), 0.0);
+
+  for (i = 0; i < nlocal; i++) {
+    nx = part2grid[i][0];
+    ny = part2grid[i][1];
+    nz = part2grid[i][2];
+    dx = nx + shiftone - (x[i][0] - boxlo[0]) * delxinv;
+    dy = ny + shiftone - (x[i][1] - boxlo[1]) * delyinv;
+    dz = nz + shiftone - (x[i][2] - boxlo[2]) * delzinv;
+
+    compute_rho1d(dx, dy, dz);
+    compute_drho1d(dx, dy, dz);
+
+    ekx = eky = ekz = ZEROF;
+    for (n = nlower; n <= nupper; n++) {
+      mz = n + nz;
+      for (m = nlower; m <= nupper; m++) {
+        my = m + ny;
+        for (l = nlower; l <= nupper; l++) {
+          mx = l + nx;
+          ekx += drho1d[0][l] * rho1d[1][m] * rho1d[2][n] * u_brick[mz][my][mx];
+          eky += rho1d[0][l] * drho1d[1][m] * rho1d[2][n] * u_brick[mz][my][mx];
+          ekz += rho1d[0][l] * rho1d[1][m] * drho1d[2][n] * u_brick[mz][my][mx];
+        }
+      }
+    }
+    ekx *= hx_inv;
+    eky *= hy_inv;
+    ekz *= hz_inv;
+
+    // convert E-field to force and subtract self forces
+
+    const double qfactor = qqrd2e * scale;
+
+    s1 = x[i][0] * hx_inv;
+    s2 = x[i][1] * hy_inv;
+    s3 = x[i][2] * hz_inv;
+    sf = sf_coeff[0] * sin(2 * MY_PI * s1);
+    sf += sf_coeff[1] * sin(4 * MY_PI * s1);
+    sf *= 2 * q[i] * q[i];
+    fele[i * 3 + 0] += qfactor * (ekx * q[i] - sf);
+
+    sf = sf_coeff[2] * sin(2 * MY_PI * s2);
+    sf += sf_coeff[3] * sin(4 * MY_PI * s2);
+    sf *= 2 * q[i] * q[i];
+    fele[i * 3 + 1] += qfactor * (eky * q[i] - sf);
+
+    sf = sf_coeff[4] * sin(2 * MY_PI * s3);
+    sf += sf_coeff[5] * sin(4 * MY_PI * s3);
+    sf *= 2 * q[i] * q[i];
+    if (slabflag != 2) {
+      fele[i * 3 + 2] += qfactor * (ekz * q[i] - sf);
+    }
+  }
+}
diff --git a/src/USER-DEEPMD/pppm_dplr.h b/src/USER-DEEPMD/pppm_dplr.h
new file mode 100644
index 0000000000..1484a16e72
--- /dev/null
+++ b/src/USER-DEEPMD/pppm_dplr.h
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: LGPL-3.0-or-later
+#ifdef KSPACE_CLASS
+// clang-format off
+KSpaceStyle(pppm/dplr, PPPMDPLR)
+// clang-format on
+#else
+
+#ifndef LMP_PPPM_DPLR_H
+#define LMP_PPPM_DPLR_H
+
+#define FLOAT_PREC double
+
+#include <iostream>
+#include <vector>
+
+#include "pppm.h"
+
+namespace LAMMPS_NS {
+
+class PPPMDPLR : public PPPM {
+ public:
+#if LAMMPS_VERSION_NUMBER < 20181109
+  // See lammps/lammps#1165
+  PPPMDPLR(class LAMMPS *, int, char **);
+#else
+  PPPMDPLR(class LAMMPS *);
+#endif
+  ~PPPMDPLR() override {};
+  void init() override;
+  const std::vector<double> &get_fele() const { return fele; };
+
+ protected:
+  void compute(int, int) override;
+  void fieldforce_ik() override;
+  void fieldforce_ad() override;
+
+ private:
+  std::vector<double> fele;
+};
+
+}  // namespace LAMMPS_NS
+
+#endif
+#endif
-- 
2.45.2

